/* eslint-disable */
// @ts-nocheck
/**
 * NFD Management Service
 * Service for querying and managing NFDs
 *
 * OpenAPI spec version: 1.0
 * Contact: feedback@txnlab.dev
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url"
import * as isomorphicFetch from "isomorphic-fetch"
import { Configuration } from "./configuration"

const BASE_PATH = "https://api.nf.domains".replace(/\/+$/, "")

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch,
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name = "RequiredError"
  constructor(
    public field: string,
    msg?: string,
  ) {
    super(msg)
  }
}

/**
 * ConsensusRecord contains information about an account that participated in consensus
 * @export
 * @interface ConsensusRecord
 */
export interface ConsensusRecord {
  /**
   *
   * @type {string}
   * @memberof ConsensusRecord
   */
  account: string
  /**
   *
   * @type {number}
   * @memberof ConsensusRecord
   */
  lastPropBlock?: number
  /**
   *
   * @type {Date}
   * @memberof ConsensusRecord
   */
  lastPropTime?: Date
  /**
   *
   * @type {number}
   * @memberof ConsensusRecord
   */
  lastVoteBlock?: number
  /**
   *
   * @type {Date}
   * @memberof ConsensusRecord
   */
  lastVoteTime?: Date
  /**
   *
   * @type {string}
   * @memberof ConsensusRecord
   */
  linkType?: string
  /**
   *
   * @type {string}
   * @memberof ConsensusRecord
   */
  ownerAccount: string
  /**
   *
   * @type {number}
   * @memberof ConsensusRecord
   */
  pctOfOnline: number
  /**
   *
   * @type {number}
   * @memberof ConsensusRecord
   */
  proposals?: number
  /**
   *
   * @type {number}
   * @memberof ConsensusRecord
   */
  rank?: number
  /**
   *
   * @type {number}
   * @memberof ConsensusRecord
   */
  votes?: number
}
/**
 *
 * @export
 * @interface ContractLockRequestBody
 */
export interface ContractLockRequestBody {
  /**
   * Whether to lock (true), or unlock (false)
   * @type {boolean}
   * @memberof ContractLockRequestBody
   */
  lock: boolean
  /**
   * Sender of transaction - needs to be owner of NFD
   * @type {string}
   * @memberof ContractLockRequestBody
   */
  sender: string
}
/**
 * Donation contains basic information about donation totals to specific addresses from accounts related to an NFD
 * @export
 * @interface Donation
 */
export interface Donation {
  /**
   * Sender or Receiver Algorand address depending on request
   * @type {string}
   * @memberof Donation
   */
  address: string
  /**
   * Total donation in microAlgos
   * @type {number}
   * @memberof Donation
   */
  total: number
}
/**
 *
 * @export
 * @interface GetQuoteResponseBody
 */
export interface GetQuoteResponseBody {
  /**
   * extra needed to cover MBR (if necessary) - price already includes this amount
   * @type {number}
   * @memberof GetQuoteResponseBody
   */
  carryCost: number
  /**
   * whether the nfd exists. if so, cost is renewal, otherwise mint (including carry)
   * @type {boolean}
   * @memberof GetQuoteResponseBody
   */
  exists: boolean
  /**
   * if nfd is in auction pricing for given buyer
   * @type {boolean}
   * @memberof GetQuoteResponseBody
   */
  inAuction: boolean
  /**
   * whether the (existing) nfd is expired
   * @type {boolean}
   * @memberof GetQuoteResponseBody
   */
  isExpired: boolean
  /**
   * price in microAlgo for 1 year w/ carry cost (if needs minted) added in. subtract carry cost for per-year cost
   * @type {number}
   * @memberof GetQuoteResponseBody
   */
  price: number
}
/**
 * Whether NFD NFT ASA ID is for authentic NFD
 * @export
 * @interface IsValidASAResponseBody
 */
export interface IsValidASAResponseBody {
  /**
   *
   * @type {number}
   * @memberof IsValidASAResponseBody
   */
  appID: number
  /**
   *
   * @type {boolean}
   * @memberof IsValidASAResponseBody
   */
  isValid: boolean
  /**
   *
   * @type {string}
   * @memberof IsValidASAResponseBody
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof IsValidASAResponseBody
   */
  name: string
}
/**
 * Whether NFD App ID is for authentic NFD
 * @export
 * @interface IsValidNFDResponseBody
 */
export interface IsValidNFDResponseBody {
  /**
   *
   * @type {boolean}
   * @memberof IsValidNFDResponseBody
   */
  isValid: boolean
  /**
   *
   * @type {string}
   * @memberof IsValidNFDResponseBody
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof IsValidNFDResponseBody
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof IsValidNFDResponseBody
   */
  sigNameAddress?: string
}
/**
 *
 * @export
 * @interface LinkAddressRequestBody
 */
export interface LinkAddressRequestBody {
  /**
   * Address(es) to link to the NFD (must be able to sign for each)
   * @type {Array<string>}
   * @memberof LinkAddressRequestBody
   */
  address: Array<string>
  /**
   * Address that will be signing the returned transactions.  Should be owner of NFD
   * @type {string}
   * @memberof LinkAddressRequestBody
   */
  sender: string
}
/**
 *
 * @export
 * @interface MintRequestBody
 */
export interface MintRequestBody {
  /**
   * Offer price in ALGO. Expiration time set prorated based on amount paid vs fixed per-year cost when years argument is used
   * @type {number}
   * @memberof MintRequestBody
   */
  algoOffer?: number
  /**
   * Address paying/signing for minting transaction
   * @type {string}
   * @memberof MintRequestBody
   */
  buyer: string
  /**
   *
   * @type {string}
   * @memberof MintRequestBody
   */
  name: string
  /**
   * Address NFD is being minted for if not buyer
   * @type {string}
   * @memberof MintRequestBody
   */
  reservedFor?: string
  /**
   * Number of years until expiration, 1 yr minimum, 20 max, extending renewal date - sets price in multiples of 1 year
   * @type {number}
   * @memberof MintRequestBody
   */
  years?: number
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * Is the error a server-side fault?
   * @type {boolean}
   * @memberof ModelError
   */
  fault: boolean
  /**
   * ID is a unique identifier for this particular occurrence of the problem.
   * @type {string}
   * @memberof ModelError
   */
  id: string
  /**
   * Message is a human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof ModelError
   */
  message: string
  /**
   * Name is the name of this class of errors.
   * @type {string}
   * @memberof ModelError
   */
  name: string
  /**
   * Is the error temporary?
   * @type {boolean}
   * @memberof ModelError
   */
  temporary: boolean
  /**
   * Is the error a timeout?
   * @type {boolean}
   * @memberof ModelError
   */
  timeout: boolean
}
/**
 * NFD contains all known information about an NFD record
 * @export
 * @interface NFD
 */
export interface NFD {
  /**
   * NFD Application ID
   * @type {number}
   * @memberof NFD
   */
  appID?: number
  /**
   * NFD ASA ID
   * @type {number}
   * @memberof NFD
   */
  asaID?: number
  /**
   * Whether the verified Avatar set in this NFD is newer (arc19) then is set into the NFD. This will only be present on direct NFD fetch and if true
   * @type {boolean}
   * @memberof NFD
   */
  avatarOutdated?: boolean
  /**
   * Verified Algorand addresses for this NFD
   * @type {Array<string>}
   * @memberof NFD
   */
  caAlgo?: Array<string>
  /**
   * Cache-Control header
   * @type {string}
   * @memberof NFD
   */
  cacheControl?: string
  /**
   *
   * @type {string}
   * @memberof NFD
   */
  category?: NFD.CategoryEnum
  /**
   * Round this data was last fetched from
   * @type {number}
   * @memberof NFD
   */
  currentAsOfBlock?: number
  /**
   * account wallets should send funds to - precedence is: caAlgo[0], unverifiedCaAlgo[0], owner
   * @type {string}
   * @memberof NFD
   */
  depositAccount?: string
  /**
   * ETag
   * @type {string}
   * @memberof NFD
   */
  etag?: string
  /**
   *
   * @type {boolean}
   * @memberof NFD
   */
  expired?: boolean
  /**
   * Tags set by the system for tracking/analytics
   * @type {Array<string>}
   * @memberof NFD
   */
  metaTags?: Array<string>
  /**
   *
   * @type {string}
   * @memberof NFD
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof NFD
   */
  nfdAccount?: string
  /**
   * Owner of NFD
   * @type {string}
   * @memberof NFD
   */
  owner?: string
  /**
   * NFD Application ID of Parent if this is a segment
   * @type {number}
   * @memberof NFD
   */
  parentAppID?: number
  /**
   *
   * @type {NFDProperties}
   * @memberof NFD
   */
  properties?: NFDProperties
  /**
   * Reserved owner of NFD
   * @type {string}
   * @memberof NFD
   */
  reservedFor?: string
  /**
   *
   * @type {string}
   * @memberof NFD
   */
  saleType?: NFD.SaleTypeEnum
  /**
   * amount NFD is being sold for (microAlgos)
   * @type {number}
   * @memberof NFD
   */
  sellAmount?: number
  /**
   * RecipientUid of NFD sales
   * @type {string}
   * @memberof NFD
   */
  seller?: string
  /**
   *
   * @type {string}
   * @memberof NFD
   */
  sigNameAddress?: string
  /**
   *
   * @type {string}
   * @memberof NFD
   */
  state?: NFD.StateEnum
  /**
   * Tags assigned to this NFD
   * @type {Array<string>}
   * @memberof NFD
   */
  tags?: Array<string>
  /**
   *
   * @type {Date}
   * @memberof NFD
   */
  timeChanged?: Date
  /**
   *
   * @type {Date}
   * @memberof NFD
   */
  timeCreated?: Date
  /**
   *
   * @type {Date}
   * @memberof NFD
   */
  timeExpires?: Date
  /**
   *
   * @type {Date}
   * @memberof NFD
   */
  timePurchased?: Date
  /**
   * Unverified (non-algo) Crypto addresses for this NFD
   * @type {{ [key: string]: Array<string>; }}
   * @memberof NFD
   */
  unverifiedCa?: { [key: string]: Array<string> }
  /**
   * Unverified Algorand addresses for this NFD
   * @type {Array<string>}
   * @memberof NFD
   */
  unverifiedCaAlgo?: Array<string>
}

/**
 * @export
 * @namespace NFD
 */
export namespace NFD {
  /**
   * @export
   * @enum {string}
   */
  export enum CategoryEnum {
    Curated = <any>"curated",
    Premium = <any>"premium",
    Common = <any>"common",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum SaleTypeEnum {
    Auction = <any>"auction",
    BuyItNow = <any>"buyItNow",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    Available = <any>"available",
    Minting = <any>"minting",
    Reserved = <any>"reserved",
    ForSale = <any>"forSale",
    Owned = <any>"owned",
    Expired = <any>"expired",
  }
}
/**
 * NFDActivity contains the property changes made in a particular NFD contract update call
 * @export
 * @interface NFDActivity
 */
export interface NFDActivity {
  /**
   * Algorand Block number of change
   * @type {number}
   * @memberof NFDActivity
   */
  block: number
  /**
   *
   * @type {string}
   * @memberof NFDActivity
   */
  cacheControl?: string
  /**
   * Changed properties
   * @type {{ [key: string]: string; }}
   * @memberof NFDActivity
   */
  changes?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof NFDActivity
   */
  etag?: string
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   * @type {string}
   * @memberof NFDActivity
   */
  matchCheck?: string
  /**
   * NFD Name
   * @type {string}
   * @memberof NFDActivity
   */
  name: string
  /**
   *
   * @type {Date}
   * @memberof NFDActivity
   */
  timeChanged: Date
}
/**
 * NFDAnalyticEvent contains a price history record for a point in time of an NFD
 * @export
 * @interface NFDAnalyticEvent
 */
export interface NFDAnalyticEvent {
  /**
   *
   * @type {number}
   * @memberof NFDAnalyticEvent
   */
  block?: number
  /**
   *
   * @type {string}
   * @memberof NFDAnalyticEvent
   */
  buyer?: string
  /**
   * extra amount paid to cover minimum balance requirements - add to price to determine total amount paid
   * @type {number}
   * @memberof NFDAnalyticEvent
   */
  carryCost?: number
  /**
   *
   * @type {string}
   * @memberof NFDAnalyticEvent
   */
  category?: NFDAnalyticEvent.CategoryEnum
  /**
   * NFD current owner - if set via includeOwner property
   * @type {string}
   * @memberof NFDAnalyticEvent
   */
  currentOwner?: string
  /**
   *
   * @type {string}
   * @memberof NFDAnalyticEvent
   */
  event?: NFDAnalyticEvent.EventEnum
  /**
   *
   * @type {string}
   * @memberof NFDAnalyticEvent
   */
  groupID?: string
  /**
   *
   * @type {Array<string>}
   * @memberof NFDAnalyticEvent
   */
  metaTags?: Array<string>
  /**
   * NFD Name
   * @type {string}
   * @memberof NFDAnalyticEvent
   */
  name?: string
  /**
   * new expiration time set from minting or renewing
   * @type {Date}
   * @memberof NFDAnalyticEvent
   */
  newExpTime?: Date
  /**
   *
   * @type {string}
   * @memberof NFDAnalyticEvent
   */
  note?: string
  /**
   * price for one year mint/renew
   * @type {number}
   * @memberof NFDAnalyticEvent
   */
  oneYearRenewalPrice?: number
  /**
   *
   * @type {string}
   * @memberof NFDAnalyticEvent
   */
  saleType?: NFDAnalyticEvent.SaleTypeEnum
  /**
   *
   * @type {string}
   * @memberof NFDAnalyticEvent
   */
  seller?: string
}

/**
 * @export
 * @namespace NFDAnalyticEvent
 */
export namespace NFDAnalyticEvent {
  /**
   * @export
   * @enum {string}
   */
  export enum CategoryEnum {
    Curated = <any>"curated",
    Premium = <any>"premium",
    Common = <any>"common",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum EventEnum {
    Minted = <any>"minted",
    Renewed = <any>"renewed",
    OfferedForSale = <any>"offeredForSale",
    CanceledSale = <any>"canceledSale",
    EscrowedOffer = <any>"escrowedOffer",
    Sold = <any>"sold",
    PostedOffer = <any>"postedOffer",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum SaleTypeEnum {
    Auction = <any>"auction",
    BuyItNow = <any>"buyItNow",
  }
}
/**
 * NFDAnalyticRecord is an NFD Analytics record in a time-series collection, with timestamp, price, and event data for that point in time.
 * @export
 * @interface NFDAnalyticRecord
 */
export interface NFDAnalyticRecord {
  /**
   *
   * @type {NFDAnalyticEvent}
   * @memberof NFDAnalyticRecord
   */
  data?: NFDAnalyticEvent
  /**
   * price of event in microAlgos
   * @type {number}
   * @memberof NFDAnalyticRecord
   */
  price?: number
  /**
   * price of event in USD
   * @type {number}
   * @memberof NFDAnalyticRecord
   */
  priceUsd?: number
  /**
   *
   * @type {Date}
   * @memberof NFDAnalyticRecord
   */
  timestamp?: Date
}
/**
 *
 * @export
 * @interface NFDAnalyticRecords
 */
export interface NFDAnalyticRecords {
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   * @type {string}
   * @memberof NFDAnalyticRecords
   */
  matchCheck?: string
  /**
   *
   * @type {Array<NFDAnalyticRecord>}
   * @memberof NFDAnalyticRecords
   */
  results: Array<NFDAnalyticRecord>
  /**
   * total number of results, with data containing paged amount based on offset/limit
   * @type {number}
   * @memberof NFDAnalyticRecords
   */
  total: number
}
/**
 * NFDProperties contains the expanded metadata stored within an NFD contracts' global-state
 * @export
 * @interface NFDProperties
 */
export interface NFDProperties {
  /**
   * Internal properties
   * @type {{ [key: string]: string; }}
   * @memberof NFDProperties
   */
  internal?: { [key: string]: string }
  /**
   * User properties
   * @type {{ [key: string]: string; }}
   * @memberof NFDProperties
   */
  userDefined?: { [key: string]: string }
  /**
   * Verified properties
   * @type {{ [key: string]: string; }}
   * @memberof NFDProperties
   */
  verified?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface NfdRecord
 */
export interface NfdRecord {
  /**
   * NFD Application ID
   * @type {number}
   * @memberof NfdRecord
   */
  appID?: number
  /**
   * NFD ASA ID
   * @type {number}
   * @memberof NfdRecord
   */
  asaID?: number
  /**
   * Whether the verified Avatar set in this NFD is newer (arc19) then is set into the NFD. This will only be present on direct NFD fetch and if true
   * @type {boolean}
   * @memberof NfdRecord
   */
  avatarOutdated?: boolean
  /**
   * Verified Algorand addresses for this NFD
   * @type {Array<string>}
   * @memberof NfdRecord
   */
  caAlgo?: Array<string>
  /**
   *
   * @type {string}
   * @memberof NfdRecord
   */
  category?: NfdRecord.CategoryEnum
  /**
   * Round this data was last fetched from
   * @type {number}
   * @memberof NfdRecord
   */
  currentAsOfBlock?: number
  /**
   * account wallets should send funds to - precedence is: caAlgo[0], unverifiedCaAlgo[0], owner
   * @type {string}
   * @memberof NfdRecord
   */
  depositAccount?: string
  /**
   *
   * @type {boolean}
   * @memberof NfdRecord
   */
  expired?: boolean
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   * @type {string}
   * @memberof NfdRecord
   */
  matchCheck?: string
  /**
   * Tags set by the system for tracking/analytics
   * @type {Array<string>}
   * @memberof NfdRecord
   */
  metaTags?: Array<string>
  /**
   *
   * @type {string}
   * @memberof NfdRecord
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof NfdRecord
   */
  nfdAccount?: string
  /**
   * Owner of NFD
   * @type {string}
   * @memberof NfdRecord
   */
  owner?: string
  /**
   * NFD Application ID of Parent if this is a segment
   * @type {number}
   * @memberof NfdRecord
   */
  parentAppID?: number
  /**
   *
   * @type {NFDProperties}
   * @memberof NfdRecord
   */
  properties?: NFDProperties
  /**
   * Reserved owner of NFD
   * @type {string}
   * @memberof NfdRecord
   */
  reservedFor?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecord
   */
  saleType?: NfdRecord.SaleTypeEnum
  /**
   * amount NFD is being sold for (microAlgos)
   * @type {number}
   * @memberof NfdRecord
   */
  sellAmount?: number
  /**
   * RecipientUid of NFD sales
   * @type {string}
   * @memberof NfdRecord
   */
  seller?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecord
   */
  sigNameAddress?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecord
   */
  state?: NfdRecord.StateEnum
  /**
   * Tags assigned to this NFD
   * @type {Array<string>}
   * @memberof NfdRecord
   */
  tags?: Array<string>
  /**
   *
   * @type {Date}
   * @memberof NfdRecord
   */
  timeChanged?: Date
  /**
   *
   * @type {Date}
   * @memberof NfdRecord
   */
  timeCreated?: Date
  /**
   *
   * @type {Date}
   * @memberof NfdRecord
   */
  timeExpires?: Date
  /**
   *
   * @type {Date}
   * @memberof NfdRecord
   */
  timePurchased?: Date
  /**
   * Unverified (non-algo) Crypto addresses for this NFD
   * @type {{ [key: string]: Array<string>; }}
   * @memberof NfdRecord
   */
  unverifiedCa?: { [key: string]: Array<string> }
  /**
   * Unverified Algorand addresses for this NFD
   * @type {Array<string>}
   * @memberof NfdRecord
   */
  unverifiedCaAlgo?: Array<string>
}

/**
 * @export
 * @namespace NfdRecord
 */
export namespace NfdRecord {
  /**
   * @export
   * @enum {string}
   */
  export enum CategoryEnum {
    Curated = <any>"curated",
    Premium = <any>"premium",
    Common = <any>"common",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum SaleTypeEnum {
    Auction = <any>"auction",
    BuyItNow = <any>"buyItNow",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    Available = <any>"available",
    Minting = <any>"minting",
    Reserved = <any>"reserved",
    ForSale = <any>"forSale",
    Owned = <any>"owned",
    Expired = <any>"expired",
  }
}
/**
 *
 * @export
 */
export type NfdRecordCollection = Array<NfdRecord>
/**
 * NFD contains all known information about an NFD record (full view)
 * @export
 * @interface NfdRecordResponseFull
 */
export interface NfdRecordResponseFull {
  /**
   * NFD Application ID
   * @type {number}
   * @memberof NfdRecordResponseFull
   */
  appID?: number
  /**
   * NFD ASA ID
   * @type {number}
   * @memberof NfdRecordResponseFull
   */
  asaID?: number
  /**
   * Whether the verified Avatar set in this NFD is newer (arc19) then is set into the NFD. This will only be present on direct NFD fetch and if true
   * @type {boolean}
   * @memberof NfdRecordResponseFull
   */
  avatarOutdated?: boolean
  /**
   * Verified Algorand addresses for this NFD
   * @type {Array<string>}
   * @memberof NfdRecordResponseFull
   */
  caAlgo?: Array<string>
  /**
   * Cache-Control header
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  cacheControl?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  category?: NfdRecordResponseFull.CategoryEnum
  /**
   * Round this data was last fetched from
   * @type {number}
   * @memberof NfdRecordResponseFull
   */
  currentAsOfBlock?: number
  /**
   * account wallets should send funds to - precedence is: caAlgo[0], unverifiedCaAlgo[0], owner
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  depositAccount?: string
  /**
   * ETag
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  etag?: string
  /**
   *
   * @type {boolean}
   * @memberof NfdRecordResponseFull
   */
  expired?: boolean
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  matchCheck?: string
  /**
   * Tags set by the system for tracking/analytics
   * @type {Array<string>}
   * @memberof NfdRecordResponseFull
   */
  metaTags?: Array<string>
  /**
   *
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  nfdAccount?: string
  /**
   * Owner of NFD
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  owner?: string
  /**
   * NFD Application ID of Parent if this is a segment
   * @type {number}
   * @memberof NfdRecordResponseFull
   */
  parentAppID?: number
  /**
   *
   * @type {NFDProperties}
   * @memberof NfdRecordResponseFull
   */
  properties?: NFDProperties
  /**
   * Reserved owner of NFD
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  reservedFor?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  saleType?: NfdRecordResponseFull.SaleTypeEnum
  /**
   * amount NFD is being sold for (microAlgos)
   * @type {number}
   * @memberof NfdRecordResponseFull
   */
  sellAmount?: number
  /**
   * RecipientUid of NFD sales
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  seller?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  sigNameAddress?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordResponseFull
   */
  state?: NfdRecordResponseFull.StateEnum
  /**
   * Tags assigned to this NFD
   * @type {Array<string>}
   * @memberof NfdRecordResponseFull
   */
  tags?: Array<string>
  /**
   *
   * @type {Date}
   * @memberof NfdRecordResponseFull
   */
  timeChanged?: Date
  /**
   *
   * @type {Date}
   * @memberof NfdRecordResponseFull
   */
  timeCreated?: Date
  /**
   *
   * @type {Date}
   * @memberof NfdRecordResponseFull
   */
  timeExpires?: Date
  /**
   *
   * @type {Date}
   * @memberof NfdRecordResponseFull
   */
  timePurchased?: Date
  /**
   * Unverified (non-algo) Crypto addresses for this NFD
   * @type {{ [key: string]: Array<string>; }}
   * @memberof NfdRecordResponseFull
   */
  unverifiedCa?: { [key: string]: Array<string> }
  /**
   * Unverified Algorand addresses for this NFD
   * @type {Array<string>}
   * @memberof NfdRecordResponseFull
   */
  unverifiedCaAlgo?: Array<string>
}

/**
 * @export
 * @namespace NfdRecordResponseFull
 */
export namespace NfdRecordResponseFull {
  /**
   * @export
   * @enum {string}
   */
  export enum CategoryEnum {
    Curated = <any>"curated",
    Premium = <any>"premium",
    Common = <any>"common",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum SaleTypeEnum {
    Auction = <any>"auction",
    BuyItNow = <any>"buyItNow",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    Available = <any>"available",
    Minting = <any>"minting",
    Reserved = <any>"reserved",
    ForSale = <any>"forSale",
    Owned = <any>"owned",
    Expired = <any>"expired",
  }
}
/**
 * DonationListV2ResponseBody is the result type for an array of NfdRecordResponse (full view)
 * @export
 */
export type NfdRecordResponseFullCollection = Array<NfdRecordResponseFull>
/**
 * NFD contains all known information about an NFD record
 * @export
 * @interface NfdRecordinaddress
 */
export interface NfdRecordinaddress {
  /**
   * NFD Application ID
   * @type {number}
   * @memberof NfdRecordinaddress
   */
  appID?: number
  /**
   * NFD ASA ID
   * @type {number}
   * @memberof NfdRecordinaddress
   */
  asaID?: number
  /**
   * Whether the verified Avatar set in this NFD is newer (arc19) then is set into the NFD. This will only be present on direct NFD fetch and if true
   * @type {boolean}
   * @memberof NfdRecordinaddress
   */
  avatarOutdated?: boolean
  /**
   * Verified Algorand addresses for this NFD
   * @type {Array<string>}
   * @memberof NfdRecordinaddress
   */
  caAlgo?: Array<string>
  /**
   * Cache-Control header
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  cacheControl?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  category?: NfdRecordinaddress.CategoryEnum
  /**
   * Round this data was last fetched from
   * @type {number}
   * @memberof NfdRecordinaddress
   */
  currentAsOfBlock?: number
  /**
   * account wallets should send funds to - precedence is: caAlgo[0], unverifiedCaAlgo[0], owner
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  depositAccount?: string
  /**
   * ETag
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  etag?: string
  /**
   *
   * @type {boolean}
   * @memberof NfdRecordinaddress
   */
  expired?: boolean
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  matchCheck?: string
  /**
   * Tags set by the system for tracking/analytics
   * @type {Array<string>}
   * @memberof NfdRecordinaddress
   */
  metaTags?: Array<string>
  /**
   *
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  nfdAccount?: string
  /**
   * Owner of NFD
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  owner?: string
  /**
   * NFD Application ID of Parent if this is a segment
   * @type {number}
   * @memberof NfdRecordinaddress
   */
  parentAppID?: number
  /**
   *
   * @type {NFDProperties}
   * @memberof NfdRecordinaddress
   */
  properties?: NFDProperties
  /**
   * Reserved owner of NFD
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  reservedFor?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  saleType?: NfdRecordinaddress.SaleTypeEnum
  /**
   * amount NFD is being sold for (microAlgos)
   * @type {number}
   * @memberof NfdRecordinaddress
   */
  sellAmount?: number
  /**
   * RecipientUid of NFD sales
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  seller?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  sigNameAddress?: string
  /**
   *
   * @type {string}
   * @memberof NfdRecordinaddress
   */
  state?: NfdRecordinaddress.StateEnum
  /**
   * Tags assigned to this NFD
   * @type {Array<string>}
   * @memberof NfdRecordinaddress
   */
  tags?: Array<string>
  /**
   *
   * @type {Date}
   * @memberof NfdRecordinaddress
   */
  timeChanged?: Date
  /**
   *
   * @type {Date}
   * @memberof NfdRecordinaddress
   */
  timeCreated?: Date
  /**
   *
   * @type {Date}
   * @memberof NfdRecordinaddress
   */
  timeExpires?: Date
  /**
   *
   * @type {Date}
   * @memberof NfdRecordinaddress
   */
  timePurchased?: Date
  /**
   * Unverified (non-algo) Crypto addresses for this NFD
   * @type {{ [key: string]: Array<string>; }}
   * @memberof NfdRecordinaddress
   */
  unverifiedCa?: { [key: string]: Array<string> }
  /**
   * Unverified Algorand addresses for this NFD
   * @type {Array<string>}
   * @memberof NfdRecordinaddress
   */
  unverifiedCaAlgo?: Array<string>
}

/**
 * @export
 * @namespace NfdRecordinaddress
 */
export namespace NfdRecordinaddress {
  /**
   * @export
   * @enum {string}
   */
  export enum CategoryEnum {
    Curated = <any>"curated",
    Premium = <any>"premium",
    Common = <any>"common",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum SaleTypeEnum {
    Auction = <any>"auction",
    BuyItNow = <any>"buyItNow",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum StateEnum {
    Available = <any>"available",
    Minting = <any>"minting",
    Reserved = <any>"reserved",
    ForSale = <any>"forSale",
    Owned = <any>"owned",
    Expired = <any>"expired",
  }
}
/**
 *
 * @export
 */
export type NfdRecordinaddressCollection = Array<NfdRecordinaddress>
/**
 *
 * @export
 * @interface NfdV2SearchRecords
 */
export interface NfdV2SearchRecords {
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   * @type {string}
   * @memberof NfdV2SearchRecords
   */
  matchCheck?: string
  /**
   *
   * @type {NfdRecordCollection}
   * @memberof NfdV2SearchRecords
   */
  nfds: NfdRecordCollection
  /**
   * total number of results, with data containing paged amount based on offset/limit
   * @type {number}
   * @memberof NfdV2SearchRecords
   */
  total: number
}
/**
 *
 * @export
 * @interface OfferRequestBody
 */
export interface OfferRequestBody {
  /**
   * Amount in microAlgo to sell the NFD for.  1 ALGO is 1,000,000 microAlgo. 100 million maximum.
   * @type {number}
   * @memberof OfferRequestBody
   */
  offer: number
  /**
   * Whether to pay the offer amount + fees to the account the NFD is reserved for.  Equivalent to 'gifting' the NFD
   * @type {boolean}
   * @memberof OfferRequestBody
   */
  payReceiver?: boolean
  /**
   *
   * @type {string}
   * @memberof OfferRequestBody
   */
  reservedFor?: string
  /**
   * Sender of transaction - needs to be owner of NFD
   * @type {string}
   * @memberof OfferRequestBody
   */
  sender: string
}
/**
 *
 * @export
 * @interface PostOfferToOwnerRequestBody
 */
export interface PostOfferToOwnerRequestBody {
  /**
   * Note to pass along to the NFD owner.  Must be provided but can be blank
   * @type {string}
   * @memberof PostOfferToOwnerRequestBody
   */
  note: string
  /**
   * Amount in microAlgo being offered to the NFD owner
   * @type {number}
   * @memberof PostOfferToOwnerRequestBody
   */
  offer: number
  /**
   *
   * @type {string}
   * @memberof PostOfferToOwnerRequestBody
   */
  sender: string
}
/**
 *
 * @export
 * @interface PurchaseRequestBody
 */
export interface PurchaseRequestBody {
  /**
   *
   * @type {string}
   * @memberof PurchaseRequestBody
   */
  buyer: string
  /**
   * Amount in microAlgo to purchase/claim the NFD for
   * @type {number}
   * @memberof PurchaseRequestBody
   */
  offer: number
}
/**
 *
 * @export
 * @interface RateLimited
 */
export interface RateLimited {
  /**
   *
   * @type {number}
   * @memberof RateLimited
   */
  limit: number
  /**
   *
   * @type {number}
   * @memberof RateLimited
   */
  secsRemaining: number
}
/**
 *
 * @export
 * @interface RenewRequestBody
 */
export interface RenewRequestBody {
  /**
   * Offer price in ALGO. Expiration time set prorated based on amount paid vs fixed per-year cost when years argument is used
   * @type {number}
   * @memberof RenewRequestBody
   */
  algoOffer?: number
  /**
   * Address paying/signing for minting transaction
   * @type {string}
   * @memberof RenewRequestBody
   */
  buyer: string
  /**
   *
   * @type {string}
   * @memberof RenewRequestBody
   */
  name: string
  /**
   * Number of years until expiration, 1 yr minimum, 20 max, extending renewal date - sets price in multiples of 1 year. If not current owner and expired, only 1 year is allowed
   * @type {number}
   * @memberof RenewRequestBody
   */
  years?: number
}
/**
 *
 * @export
 * @interface RescindOfferRequestBody
 */
export interface RescindOfferRequestBody {
  /**
   * Sender of transaction - needs to be owner of NFD
   * @type {string}
   * @memberof RescindOfferRequestBody
   */
  sender: string
}
/**
 *
 * @export
 * @interface SegmentLockRequestBody
 */
export interface SegmentLockRequestBody {
  /**
   * Whether to lock (true), or unlock (false)
   * @type {boolean}
   * @memberof SegmentLockRequestBody
   */
  lock: boolean
  /**
   * amount users minting off the segment have to pay to mint in USD (in cents - ie: 300 = $3.00). Set to 0 if locking
   * @type {number}
   * @memberof SegmentLockRequestBody
   */
  sellAmount: number
  /**
   * Sender of transaction - needs to be owner of NFD
   * @type {string}
   * @memberof SegmentLockRequestBody
   */
  sender: string
}
/**
 *
 * @export
 * @interface SendFromVaultRequestBody
 */
export interface SendFromVaultRequestBody {
  /**
   * Base amount (in base units of specified asset - so decimals must be considered) of asset to send.   If multiple assets are specified, amount is should be 0 as ALL of each are sent and closed out
   * @type {number}
   * @memberof SendFromVaultRequestBody
   */
  amount?: number
  /**
   * String version of Base amount (in base units of specified asset - so decimals must be considered) of asset to send.  This is used to work around JS deficiencies with bigint
   * @type {string}
   * @memberof SendFromVaultRequestBody
   */
  amountStr?: string
  /**
   * Algorand ASA IDs to transfer FROM vault - use asset 0 to send ALGO.  Specifying multiple assets means ALL of each are sent and amount is ignored. If receiver is a vault and needs to opt-in, then need MBR/opt-in pairs (5 pairs - 8  opt-ins each - 40 assets), then 6 send calls of 7 assets w/ 5 at end for total of 40.  If receiver is already opted-in, then 112 (7 per txn, 16 tnxs) is max.
   * @type {Array<number>}
   * @memberof SendFromVaultRequestBody
   */
  assets: Array<number>
  /**
   * Optional note to include in asset send transaction
   * @type {string}
   * @memberof SendFromVaultRequestBody
   */
  note?: string
  /**
   * Algorand account or NFD Name (if vault receiver) the asset(s) should be sent to
   * @type {string}
   * @memberof SendFromVaultRequestBody
   */
  receiver: string
  /**
   * Specifies that the receiver account is something the caller can sign for. If specified, then opt-in transactions it signs may be included
   * @type {boolean}
   * @memberof SendFromVaultRequestBody
   */
  receiverCanSign?: boolean
  /**
   * Type of receiver, 'account', or 'nfdVault'
   * @type {string}
   * @memberof SendFromVaultRequestBody
   */
  receiverType?: SendFromVaultRequestBody.ReceiverTypeEnum
  /**
   * Sender of transaction, must be NFD owner
   * @type {string}
   * @memberof SendFromVaultRequestBody
   */
  sender: string
}

/**
 * @export
 * @namespace SendFromVaultRequestBody
 */
export namespace SendFromVaultRequestBody {
  /**
   * @export
   * @enum {string}
   */
  export enum ReceiverTypeEnum {
    Account = <any>"account",
    NfdVault = <any>"nfdVault",
  }
}
/**
 *
 * @export
 * @interface SendToVaultRequestBody
 */
export interface SendToVaultRequestBody {
  /**
   * Base amount (in base units of specified asset - so decimals must be considered) of asset to send.   If multiple assets specified, amount is ignored and ALL of each are sent
   * @type {number}
   * @memberof SendToVaultRequestBody
   */
  amount?: number
  /**
   * String version of Base amount (in base units of specified asset - so decimals must be considered) of asset to send.  This is used to work around JS deficiencies with bigint
   * @type {string}
   * @memberof SendToVaultRequestBody
   */
  amountStr?: string
  /**
   * Algorand ASA IDs to transfer (and opt-in inside vault if necessary) - use asset 0 to send ALGO.  Specifying multiple assets means ALL of each are sent and amount is ignored. 13 is max assets that can be specified if they're being sent (2 for MBR payments, 2 for opt-in txns (8+4 asset opt-ins), 12 asset transfers).  If opt-in only then 64 is maximum (1 MBR per 8 assets, 8 assets per txn * 8 txns)
   * @type {Array<number>}
   * @memberof SendToVaultRequestBody
   */
  assets: Array<number>
  /**
   * Optional note to include in asset send transaction
   * @type {string}
   * @memberof SendToVaultRequestBody
   */
  note?: string
  /**
   * Whether to only opt-in to the asset, instead of including asset transfer txn
   * @type {boolean}
   * @memberof SendToVaultRequestBody
   */
  optInOnly: boolean
  /**
   *
   * @type {string}
   * @memberof SendToVaultRequestBody
   */
  sender: string
}
/**
 *
 * @export
 * @interface SetPrimaryAddressRequestBody
 */
export interface SetPrimaryAddressRequestBody {
  /**
   * The address (already linked) to make primary - swapping into position if necessary
   * @type {string}
   * @memberof SetPrimaryAddressRequestBody
   */
  address: string
  /**
   * Address that will be signing the returned transactions.  Should be owner of NFD
   * @type {string}
   * @memberof SetPrimaryAddressRequestBody
   */
  sender: string
}
/**
 *
 * @export
 * @interface TotalsOKResponseBody
 */
export interface TotalsOKResponseBody {
  /**
   *
   * @type {TotalsOKResponseBodyContractTotals}
   * @memberof TotalsOKResponseBody
   */
  contractTotals: TotalsOKResponseBodyContractTotals
  /**
   * NFDs that have expired
   * @type {number}
   * @memberof TotalsOKResponseBody
   */
  expiredTotal: number
  /**
   *
   * @type {number}
   * @memberof TotalsOKResponseBody
   */
  forSale: number
  /**
   * Not returned, used in tagging for response to indicate if-none-match etag matched
   * @type {string}
   * @memberof TotalsOKResponseBody
   */
  matchCheck?: string
  /**
   *
   * @type {TotalsOKResponseBodyMintedTotals}
   * @memberof TotalsOKResponseBody
   */
  mintedTotals: TotalsOKResponseBodyMintedTotals
  /**
   *
   * @type {TotalsOKResponseBodyMintedTotals}
   * @memberof TotalsOKResponseBody
   */
  segmentTotals: TotalsOKResponseBodyMintedTotals
  /**
   *
   * @type {TotalsOKResponseBodyMintedTotals}
   * @memberof TotalsOKResponseBody
   */
  soldTotals: TotalsOKResponseBodyMintedTotals
  /**
   *
   * @type {number}
   * @memberof TotalsOKResponseBody
   */
  total: number
  /**
   *
   * @type {number}
   * @memberof TotalsOKResponseBody
   */
  totalSegments: number
  /**
   *
   * @type {number}
   * @memberof TotalsOKResponseBody
   */
  uniqueOwners: number
}
/**
 *
 * @export
 * @interface TotalsOKResponseBodyContractTotals
 */
export interface TotalsOKResponseBodyContractTotals {
  /**
   * Contract versions
   * @type {{ [key: string]: number; }}
   * @memberof TotalsOKResponseBodyContractTotals
   */
  allVersions?: { [key: string]: number }
  /**
   * Contract versions
   * @type {{ [key: string]: number; }}
   * @memberof TotalsOKResponseBodyContractTotals
   */
  majorVersions?: { [key: string]: number }
}
/**
 *
 * @export
 * @interface TotalsOKResponseBodyMintedTotals
 */
export interface TotalsOKResponseBodyMintedTotals {
  /**
   *
   * @type {number}
   * @memberof TotalsOKResponseBodyMintedTotals
   */
  day?: number
  /**
   *
   * @type {number}
   * @memberof TotalsOKResponseBodyMintedTotals
   */
  lifetime?: number
  /**
   *
   * @type {number}
   * @memberof TotalsOKResponseBodyMintedTotals
   */
  month?: number
  /**
   *
   * @type {number}
   * @memberof TotalsOKResponseBodyMintedTotals
   */
  week?: number
}
/**
 * TwitterRecord contains information about an NFD w/ Verified Twitter account and basic info on its twitter metrics
 * @export
 * @interface TwitterRecord
 */
export interface TwitterRecord {
  /**
   *
   * @type {number}
   * @memberof TwitterRecord
   */
  followers: number
  /**
   *
   * @type {number}
   * @memberof TwitterRecord
   */
  following: number
  /**
   *
   * @type {NFD}
   * @memberof TwitterRecord
   */
  nfd: NFD
  /**
   *
   * @type {Date}
   * @memberof TwitterRecord
   */
  timeChanged: Date
  /**
   *
   * @type {number}
   * @memberof TwitterRecord
   */
  tweets: number
  /**
   *
   * @type {string}
   * @memberof TwitterRecord
   */
  twitterHandle: string
}
/**
 *
 * @export
 * @interface UpdatePartialRequestBody
 */
export interface UpdatePartialRequestBody {
  /**
   *
   * @type {NFDProperties}
   * @memberof UpdatePartialRequestBody
   */
  properties: NFDProperties
  /**
   * Address that will be signing the returned transactions.  Should be owner of NFD
   * @type {string}
   * @memberof UpdatePartialRequestBody
   */
  sender: string
}
/**
 *
 * @export
 * @interface VerifyConfirmRequestBody
 */
export interface VerifyConfirmRequestBody {
  /**
   * Challenge value, optional depending on verification type
   * @type {string}
   * @memberof VerifyConfirmRequestBody
   */
  challenge?: string
}
/**
 * Whether verification was successful
 * @export
 * @interface VerifyConfirmResponseBody
 */
export interface VerifyConfirmResponseBody {
  /**
   *
   * @type {boolean}
   * @memberof VerifyConfirmResponseBody
   */
  confirmed: boolean
}
/**
 *
 * @export
 * @interface VerifyRequestRequestBody
 */
export interface VerifyRequestRequestBody {
  /**
   * User defined field name to verify
   * @type {string}
   * @memberof VerifyRequestRequestBody
   */
  fieldToVerify: VerifyRequestRequestBody.FieldToVerifyEnum
  /**
   *
   * @type {string}
   * @memberof VerifyRequestRequestBody
   */
  name: string
  /**
   * Sender of transaction - needs to be owner of NFD
   * @type {string}
   * @memberof VerifyRequestRequestBody
   */
  sender: string
}

/**
 * @export
 * @namespace VerifyRequestRequestBody
 */
export namespace VerifyRequestRequestBody {
  /**
   * @export
   * @enum {string}
   */
  export enum FieldToVerifyEnum {
    Twitter = <any>"twitter",
    Github = <any>"github",
    Domain = <any>"domain",
    Email = <any>"email",
    Avatar = <any>"avatar",
    Banner = <any>"banner",
  }
}
/**
 * Data to use as part of verification
 * @export
 * @interface VerifyRequestResponseBody
 */
export interface VerifyRequestResponseBody {
  /**
   * Challenge to be used as part of verification process, with use specific to each field
   * @type {string}
   * @memberof VerifyRequestResponseBody
   */
  challenge: string
  /**
   * ID of challenge, must be used in subsequent confirmation call but may be blank
   * @type {string}
   * @memberof VerifyRequestResponseBody
   */
  id: string
  /**
   * If set, no confirmation is required, the verify call was sufficient
   * @type {boolean}
   * @memberof VerifyRequestResponseBody
   */
  validated?: boolean
}
/**
 *
 * @export
 * @interface VersionResponseBody
 */
export interface VersionResponseBody {
  /**
   *
   * @type {string}
   * @memberof VersionResponseBody
   */
  appVersion: string
  /**
   *
   * @type {string}
   * @memberof VersionResponseBody
   */
  contractVersion: string
}
/**
 * InfoApi - fetch parameter creator
 * @export
 */
export const InfoApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns version information for the service
     * @summary version info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoVersion(options: any = {}): FetchArgs {
      const localVarPath = `/info/version`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * YAML document containing the API swagger definition
     * @summary Download ./pubfiles/openapi3.yaml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoinfoopenapi3Yaml(options: any = {}): FetchArgs {
      const localVarPath = `/info/openapi3.yaml`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns version information for the service
     * @summary version info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoVersion(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<VersionResponseBody> {
      const localVarFetchArgs = InfoApiFetchParamCreator(configuration).infoVersion(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * YAML document containing the API swagger definition
     * @summary Download ./pubfiles/openapi3.yaml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoinfoopenapi3Yaml(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs =
        InfoApiFetchParamCreator(configuration).infoinfoopenapi3Yaml(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response
            } else {
              throw response
            }
          },
        )
      }
    },
  }
}

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Returns version information for the service
     * @summary version info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoVersion(options?: any) {
      return InfoApiFp(configuration).infoVersion(options)(fetch, basePath)
    },
    /**
     * YAML document containing the API swagger definition
     * @summary Download ./pubfiles/openapi3.yaml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    infoinfoopenapi3Yaml(options?: any) {
      return InfoApiFp(configuration).infoinfoopenapi3Yaml(options)(fetch, basePath)
    },
  }
}

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
  /**
   * Returns version information for the service
   * @summary version info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfoApi
   */
  public infoVersion(options?: any) {
    return InfoApiFp(this.configuration).infoVersion(options)(this.fetch, this.basePath)
  }

  /**
   * YAML document containing the API swagger definition
   * @summary Download ./pubfiles/openapi3.yaml
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfoApi
   */
  public infoinfoopenapi3Yaml(options?: any) {
    return InfoApiFp(this.configuration).infoinfoopenapi3Yaml(options)(this.fetch, this.basePath)
  }
}
/**
 * NfdApi - fetch parameter creator
 * @export
 */
export const NfdApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Fetch change activity for an NFD, specifically general 'block-level' deltas for an NFD
     * @summary Fetch change activity for an NFD
     * @param {Array<string>} name Name(s) of NFDs to fetch activity for.  Specify the same query parameter multiple times for each nane, ie: name&#x3D;xxx&amp;name&#x3D;yyy&amp;name&#x3D;zzz\&quot;)
     * @param {string} [type] type of activity to retrieve
     * @param {Date} [afterTime] Fetch events that occurred only after the specified time
     * @param {number} [limit] Limit the number of results returned, per NFD - max 50
     * @param {string} [sort] What to sort on - descending timestamp is default
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdActivity(
      name: Array<string>,
      type?: string,
      afterTime?: Date,
      limit?: number,
      sort?: string,
      ifNoneMatch?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdActivity.",
        )
      }
      const localVarPath = `/nfd/activity`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (name) {
        localVarQueryParameter["name"] = name
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type
      }

      if (afterTime !== undefined) {
        localVarQueryParameter["afterTime"] = (afterTime as any).toISOString()
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Fetch NFD analytics via various filters
     * @summary Fetch NFD analytics via various filters
     * @param {string} [name] name or partial match of NFD name to filter on
     * @param {string} [buyer] Buyer address to filter on
     * @param {string} [seller] Seller address to filter on
     * @param {Array<string>} [event] one or more events to filter on
     * @param {boolean} [requireBuyer] Whether the buyer property must be present in the data.  Setting this will exclude auction mint events for eg
     * @param {boolean} [includeOwner] Whether to add a currentOwner property to each event with the &#x27;current&#x27; owner of the NFD referenced by that event
     * @param {boolean} [excludeNFDAsSeller] Whether to exclude events where NFDomains is the seller.  If set to true, and filtering on &#x27;sold&#x27; event for eg, returned items will will be secondary sales only.
     * @param {Array<string>} [category]
     * @param {Array<string>} [saleType]
     * @param {Array<string>} [length] Length of NFD
     * @param {Array<string>} [traits] Traits of NFD
     * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
     * @param {number} [minPrice] Minimum price of NFD
     * @param {number} [maxPrice] Maximum price of NFD
     * @param {Date} [afterTime] Fetch analytics events that occurred only after the specified time
     * @param {number} [limit] Limit the number of results returned - max 200
     * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     * @param {string} [sort] What to sort on - descending timestamp is default
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdAnalytics(
      name?: string,
      buyer?: string,
      seller?: string,
      event?: Array<string>,
      requireBuyer?: boolean,
      includeOwner?: boolean,
      excludeNFDAsSeller?: boolean,
      category?: Array<string>,
      saleType?: Array<string>,
      length?: Array<string>,
      traits?: Array<string>,
      parentAppID?: number,
      minPrice?: number,
      maxPrice?: number,
      afterTime?: Date,
      limit?: number,
      offset?: number,
      sort?: string,
      ifNoneMatch?: string,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/nfd/analytics`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (name !== undefined) {
        localVarQueryParameter["name"] = name
      }

      if (buyer !== undefined) {
        localVarQueryParameter["buyer"] = buyer
      }

      if (seller !== undefined) {
        localVarQueryParameter["seller"] = seller
      }

      if (event) {
        localVarQueryParameter["event"] = event
      }

      if (requireBuyer !== undefined) {
        localVarQueryParameter["requireBuyer"] = requireBuyer
      }

      if (includeOwner !== undefined) {
        localVarQueryParameter["includeOwner"] = includeOwner
      }

      if (excludeNFDAsSeller !== undefined) {
        localVarQueryParameter["excludeNFDAsSeller"] = excludeNFDAsSeller
      }

      if (category) {
        localVarQueryParameter["category"] = category
      }

      if (saleType) {
        localVarQueryParameter["saleType"] = saleType
      }

      if (length) {
        localVarQueryParameter["length"] = length
      }

      if (traits) {
        localVarQueryParameter["traits"] = traits
      }

      if (parentAppID !== undefined) {
        localVarQueryParameter["parentAppID"] = parentAppID
      }

      if (minPrice !== undefined) {
        localVarQueryParameter["minPrice"] = minPrice
      }

      if (maxPrice !== undefined) {
        localVarQueryParameter["maxPrice"] = maxPrice
      }

      if (afterTime !== undefined) {
        localVarQueryParameter["afterTime"] = (afterTime as any).toISOString()
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Fetch badge information (ie: donations) for an NFD
     * @summary Fetch badge information (donations/etc) for an NFD
     * @param {string} name
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdBadges(name: string, ifNoneMatch?: string, options: any = {}): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdBadges.",
        )
      }
      const localVarPath = `/nfd/badges/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Browse NFDs via various filters
     * @param {string} [name] name or partial match of NFD name to filter on
     * @param {Array<string>} [category]
     * @param {Array<string>} [saleType]
     * @param {Array<string>} [state]
     * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
     * @param {Array<string>} [length] Length of NFD
     * @param {Array<string>} [traits] Traits of NFD
     * @param {string} [owner] An Algorand account address to find all NFDs owned by that address
     * @param {string} [reservedFor] An Algorand account address to find all NFDs reserved for that address
     * @param {string} [prefix] The start of an NFD name, fetching multiple NFDs that have that prefix
     * @param {string} [substring] Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
     * @param {string} [vproperty] Verified property name to search on - specify value with vvalue
     * @param {string} [vvalue] Value to find in the vproperty field specified with the vproperty parameter
     * @param {number} [minPrice] Minimum price of NFD
     * @param {number} [maxPrice] Maximum price of NFD
     * @param {Date} [changedAfter] Fetch NFDs that changed after the specified timestamp
     * @param {number} [limit] Limit the number of results returned - max 200
     * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     * @param {string} [sort] What to sort on
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdBrowse(
      name?: string,
      category?: Array<string>,
      saleType?: Array<string>,
      state?: Array<string>,
      parentAppID?: number,
      length?: Array<string>,
      traits?: Array<string>,
      owner?: string,
      reservedFor?: string,
      prefix?: string,
      substring?: string,
      vproperty?: string,
      vvalue?: string,
      minPrice?: number,
      maxPrice?: number,
      changedAfter?: Date,
      limit?: number,
      offset?: number,
      sort?: string,
      view?: string,
      ifNoneMatch?: string,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/nfd/browse`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (name !== undefined) {
        localVarQueryParameter["name"] = name
      }

      if (category) {
        localVarQueryParameter["category"] = category
      }

      if (saleType) {
        localVarQueryParameter["saleType"] = saleType
      }

      if (state) {
        localVarQueryParameter["state"] = state
      }

      if (parentAppID !== undefined) {
        localVarQueryParameter["parentAppID"] = parentAppID
      }

      if (length) {
        localVarQueryParameter["length"] = length
      }

      if (traits) {
        localVarQueryParameter["traits"] = traits
      }

      if (owner !== undefined) {
        localVarQueryParameter["owner"] = owner
      }

      if (reservedFor !== undefined) {
        localVarQueryParameter["reservedFor"] = reservedFor
      }

      if (prefix !== undefined) {
        localVarQueryParameter["prefix"] = prefix
      }

      if (substring !== undefined) {
        localVarQueryParameter["substring"] = substring
      }

      if (vproperty !== undefined) {
        localVarQueryParameter["vproperty"] = vproperty
      }

      if (vvalue !== undefined) {
        localVarQueryParameter["vvalue"] = vvalue
      }

      if (minPrice !== undefined) {
        localVarQueryParameter["minPrice"] = minPrice
      }

      if (maxPrice !== undefined) {
        localVarQueryParameter["maxPrice"] = maxPrice
      }

      if (changedAfter !== undefined) {
        localVarQueryParameter["changedAfter"] = (changedAfter as any).toISOString()
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view
      }

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get top consensus leaders
     * @summary consensusLeaders nfd
     * @param {boolean} [requireNFD] should it only match against accounts matching NFD linked addresses
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdConsensusLeaders(requireNFD?: boolean, ifNoneMatch?: string, options: any = {}): FetchArgs {
      const localVarPath = `/nfd/consensus/leaders`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (requireNFD !== undefined) {
        localVarQueryParameter["requireNFD"] = requireNFD
      }

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get general metrics about Algorand consensus
     * @summary consensusMetrics nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdConsensusMetrics(ifNoneMatch?: string, options: any = {}): FetchArgs {
      const localVarPath = `/nfd/consensus/metrics`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Lock/Unlock an NFD contract - if locked, the contract can never being modified until unlocked again by the owner.
     * @summary contractLock nfd
     * @param {ContractLockRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdContractLock(body: ContractLockRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdContractLock.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdContractLock.",
        )
      }
      const localVarPath = `/nfd/contract/lock/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"ContractLockRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Request upgrade of a pre 2.11 NFD to 2.11 (going no further)
     * @summary contractUpgrade nfd
     * @param {RescindOfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdContractUpgrade(body: RescindOfferRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdContractUpgrade.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdContractUpgrade.",
        )
      }
      const localVarPath = `/nfd/contract/upgrade/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"RescindOfferRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Request upgrade of a 2.11 or 3.x NFD to 3.x+ (post renewals). First switch to 3.x will pay 1 year renewal fee
     * @summary ContractUpgradeV3 nfd
     * @param {RescindOfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdContractUpgradeV3(
      body: RescindOfferRequestBody,
      name: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdContractUpgradeV3.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdContractUpgradeV3.",
        )
      }
      const localVarPath = `/nfd/v3/contract/upgrade/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"RescindOfferRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get top donors to a specific NFD Donation target
     * @summary donationLeadersV2 nfd
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdDonationLeadersV2(name: string, options: any = {}): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdDonationLeadersV2.",
        )
      }
      const localVarPath = `/nfd/v2/donations/leaders/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Fetch list of tracked Donation NFD 'targets'.
     * @summary donationListV2 nfd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdDonationListV2(options: any = {}): FetchArgs {
      const localVarPath = `/nfd/v2/donations/list`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Fetch donation activity for an NFD, totalling amounts sent 'to' designated donation accounts
     * @summary donations nfd
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdDonations(name: string, options: any = {}): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdDonations.",
        )
      }
      const localVarPath = `/nfd/donations/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get the primary NFD for an address.  Must be verified address, or if allowUnverified is set, it may match against an unverified address
     * @summary Reverse Address lookup with results returned per address
     * @param {Array<string>} address one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address&#x3D;xxx&amp;address&#x3D;yyy&amp;address&#x3D;zzz
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
     * @param {boolean} [allowUnverified] Whether to allow unverified addresses to match (and only if its only match).  Defaults to false
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetLookup(
      address: Array<string>,
      view?: string,
      allowUnverified?: boolean,
      ifNoneMatch?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'address' is not null or undefined
      if (address === null || address === undefined) {
        throw new RequiredError(
          "address",
          "Required parameter address was null or undefined when calling nfdGetLookup.",
        )
      }
      const localVarPath = `/nfd/lookup`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (address) {
        localVarQueryParameter["address"] = address
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view
      }

      if (allowUnverified !== undefined) {
        localVarQueryParameter["allowUnverified"] = allowUnverified
      }

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get a specific NFD by name or by its application ID
     * @summary Get a specific NFD by name or by its application ID
     * @param {string} nameOrID
     * @param {string} [view] View of data to return, tiny, brief (default), or full
     * @param {boolean} [poll] Use if polling waiting for state change - causes notFound to return as 204 instead of 404.  Should only be used when waiting for an NFD to transition from not-existing to being reserved for user to claim
     * @param {boolean} [nocache] Set to true to return a never-cached result.  Use sparingly and only during certain &#x27;NFD already exists&#x27; UX state transitions.
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetNFD(
      nameOrID: string,
      view?: string,
      poll?: boolean,
      nocache?: boolean,
      ifNoneMatch?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'nameOrID' is not null or undefined
      if (nameOrID === null || nameOrID === undefined) {
        throw new RequiredError(
          "nameOrID",
          "Required parameter nameOrID was null or undefined when calling nfdGetNFD.",
        )
      }
      const localVarPath = `/nfd/{nameOrID}`.replace(
        `{${"nameOrID"}}`,
        encodeURIComponent(String(nameOrID)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (view !== undefined) {
        localVarQueryParameter["view"] = view
      }

      if (poll !== undefined) {
        localVarQueryParameter["poll"] = poll
      }

      if (nocache !== undefined) {
        localVarQueryParameter["nocache"] = nocache
      }

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get all NFDs which have been explicitly linked to one or more verified [or unverified] Algorand address(es).  Unverified addresses will match but return as unverifiedCaAlgo array.  These should be treated specially and not have the same trust level as verified addresses as they can be falsely attributed.  The caAlgo array is what should be trusted for things like NFT creation addresses. For reverse lookups returning multiple NFDs, the first result should be used.
     * @summary Reverse Address lookup with results returned per address
     * @param {Array<string>} address one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address&#x3D;xxx&amp;address&#x3D;yyy&amp;address&#x3D;zzz
     * @param {number} [limit] Limit the total number of NFDs returned - automatically changed to at least be 1 per address
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetNFDsForAddressesV2(
      address: Array<string>,
      limit?: number,
      view?: string,
      ifNoneMatch?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'address' is not null or undefined
      if (address === null || address === undefined) {
        throw new RequiredError(
          "address",
          "Required parameter address was null or undefined when calling nfdGetNFDsForAddressesV2.",
        )
      }
      const localVarPath = `/nfd/v2/address`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (address) {
        localVarQueryParameter["address"] = address
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view
      }

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns NameSig address for an NFD name (usable for V1 only)
     * @summary getNameSig nfd
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetNameSig(name: string, options: any = {}): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdGetNameSig.",
        )
      }
      const localVarPath = `/nfd/nameSig/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * get price / carry cost to mint or rewnew an NFD (if existing)
     * @summary getQuote nfd
     * @param {string} buyer Address requesting price. Optional, but important when getting quote on existing nfd that is expired. If expired, then owner can renew for base price, but if not existing (but expired) owner, then the price is reverse-auction format over 28 days.
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetQuote(buyer: string, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'buyer' is not null or undefined
      if (buyer === null || buyer === undefined) {
        throw new RequiredError(
          "buyer",
          "Required parameter buyer was null or undefined when calling nfdGetQuote.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdGetQuote.",
        )
      }
      const localVarPath = `/nfd/getQuote/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (buyer !== undefined) {
        localVarQueryParameter["buyer"] = buyer
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns RevAddress address for an NFD name (usable for V1 only)
     * @summary getRevAddressSig nfd
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetRevAddressSig(address: string, options: any = {}): FetchArgs {
      // verify required parameter 'address' is not null or undefined
      if (address === null || address === undefined) {
        throw new RequiredError(
          "address",
          "Required parameter address was null or undefined when calling nfdGetRevAddressSig.",
        )
      }
      const localVarPath = `/nfd/revAddressSig/{address}`.replace(
        `{${"address"}}`,
        encodeURIComponent(String(address)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Determines if specified NFD NFT ASA ID is authentic NFD
     * @summary isValidASA nfd
     * @param {number} asaID Asset ID of a presumed NFD ASA to verify.  The API will verify the found asset references an NFD that in turn references that asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdIsValidASA(asaID: number, options: any = {}): FetchArgs {
      // verify required parameter 'asaID' is not null or undefined
      if (asaID === null || asaID === undefined) {
        throw new RequiredError(
          "asaID",
          "Required parameter asaID was null or undefined when calling nfdIsValidASA.",
        )
      }
      const localVarPath = `/nfd/isValidASA/{asaID}`.replace(
        `{${"asaID"}}`,
        encodeURIComponent(String(asaID)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Determines if specified NFD Application ID is authentic
     * @summary isValidNFD nfd
     * @param {number} appID Application ID of a presumed NFD to verify.  The API will perform a forward-name lookup of the name within the NFD to verify it points to the same ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdIsValidNFD(appID: number, options: any = {}): FetchArgs {
      // verify required parameter 'appID' is not null or undefined
      if (appID === null || appID === undefined) {
        throw new RequiredError(
          "appID",
          "Required parameter appID was null or undefined when calling nfdIsValidNFD.",
        )
      }
      const localVarPath = `/nfd/isValid/{appID}`.replace(
        `{${"appID"}}`,
        encodeURIComponent(String(appID)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Link one or more addresses to an NFD, adding to the reverse-address lookups as well as to this NFD.  Sender must be owner, and each added address must be able to be signed for.
     * @summary linkAddress nfd
     * @param {LinkAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdLinkAddress(body: LinkAddressRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdLinkAddress.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdLinkAddress.",
        )
      }
      const localVarPath = `/nfd/links/addAddress/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"LinkAddressRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Mint a new NFD, with user buying specified NFD and paying for a prorated amount of time based on its yearly price.
     * @summary mint nfd
     * @param {MintRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdMint(body: MintRequestBody, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdMint.",
        )
      }
      const localVarPath = `/nfd/mint`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"MintRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Offer up an NFD for sale - specifying price and optionally an address it is reserved for.
     * @summary offer nfd
     * @param {OfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdOffer(body: OfferRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdOffer.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdOffer.",
        )
      }
      const localVarPath = `/nfd/offer/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"OfferRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Post an offer to buy to the owner of an NFD, offering up a particular amount with optional note for them to consider
     * @summary postOfferToOwner nfd
     * @param {PostOfferToOwnerRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdPostOfferToOwner(
      body: PostOfferToOwnerRequestBody,
      name: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdPostOfferToOwner.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdPostOfferToOwner.",
        )
      }
      const localVarPath = `/nfd/postOfferToOwner/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"PostOfferToOwnerRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Purchase an NFD for sale - specifying buyer (to sign transaction) and price
     * @summary purchase nfd
     * @param {PurchaseRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdPurchase(body: PurchaseRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdPurchase.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdPurchase.",
        )
      }
      const localVarPath = `/nfd/purchase/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"PurchaseRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Renew or extend the expiration of an NFD.  If current owner, renews at base price. If other owner, can take ownership but goes through reverse auction process for first 28 days where price drops to base price - with price being for 1 year
     * @summary renew nfd
     * @param {RenewRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdRenew(body: RenewRequestBody, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdRenew.",
        )
      }
      const localVarPath = `/nfd/renew`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"RenewRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Rescind offer of sale. Claiming NFD back for self, and removing it for sale.
     * @summary rescindOffer nfd
     * @param {RescindOfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdRescindOffer(body: RescindOfferRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdRescindOffer.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdRescindOffer.",
        )
      }
      const localVarPath = `/nfd/rescindOffer/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"RescindOfferRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Search NFDs via various filters
     * @summary Search NFDs via various filters
     * @param {string} [name] name or partial match of NFD name to filter on
     * @param {Array<string>} [category]
     * @param {Array<string>} [saleType]
     * @param {Array<string>} [state]
     * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
     * @param {Array<string>} [length] Length of NFD
     * @param {Array<string>} [traits] Traits of NFD
     * @param {string} [owner] An Algorand account address to find all NFDs owned by that address
     * @param {string} [reservedFor] An Algorand account address to find all NFDs reserved for that address
     * @param {boolean} [excludeUserReserved] Should NFDs reserved for an account (transfers for example or unclaimed winning auctions) be excluded
     * @param {string} [prefix] The start of an NFD name, fetching multiple NFDs that have that prefix
     * @param {string} [substring] Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
     * @param {string} [vproperty] Verified property name to search on - specify value with vvalue
     * @param {string} [vvalue] Value to find in the vproperty field specified with the vproperty parameter
     * @param {boolean} [segmentLocked] Whether to explicitly filter on segments being locked or unlocked.  Typically only valuable when filtering on unlocked
     * @param {boolean} [segmentRoot] Whether to explicitly filter on NFD roots or segments.  True to only see roots, False to only see segments.
     * @param {number} [minPrice] Minimum price of NFD
     * @param {number} [maxPrice] Maximum price of NFD
     * @param {number} [minPriceUsd] Minimum price of NFD Segment in USD (cents)
     * @param {number} [maxPriceUsd] Maximum price of NFD Segment in USD (cents)
     * @param {Date} [changedAfter] Fetch NFDs that changed after the specified timestamp
     * @param {number} [limit] Limit the number of results returned - max 200
     * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     * @param {string} [sort] What to sort on
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSearchV2(
      name?: string,
      category?: Array<string>,
      saleType?: Array<string>,
      state?: Array<string>,
      parentAppID?: number,
      length?: Array<string>,
      traits?: Array<string>,
      owner?: string,
      reservedFor?: string,
      excludeUserReserved?: boolean,
      prefix?: string,
      substring?: string,
      vproperty?: string,
      vvalue?: string,
      segmentLocked?: boolean,
      segmentRoot?: boolean,
      minPrice?: number,
      maxPrice?: number,
      minPriceUsd?: number,
      maxPriceUsd?: number,
      changedAfter?: Date,
      limit?: number,
      offset?: number,
      sort?: string,
      view?: string,
      ifNoneMatch?: string,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/nfd/v2/search`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (name !== undefined) {
        localVarQueryParameter["name"] = name
      }

      if (category) {
        localVarQueryParameter["category"] = category
      }

      if (saleType) {
        localVarQueryParameter["saleType"] = saleType
      }

      if (state) {
        localVarQueryParameter["state"] = state
      }

      if (parentAppID !== undefined) {
        localVarQueryParameter["parentAppID"] = parentAppID
      }

      if (length) {
        localVarQueryParameter["length"] = length
      }

      if (traits) {
        localVarQueryParameter["traits"] = traits
      }

      if (owner !== undefined) {
        localVarQueryParameter["owner"] = owner
      }

      if (reservedFor !== undefined) {
        localVarQueryParameter["reservedFor"] = reservedFor
      }

      if (excludeUserReserved !== undefined) {
        localVarQueryParameter["excludeUserReserved"] = excludeUserReserved
      }

      if (prefix !== undefined) {
        localVarQueryParameter["prefix"] = prefix
      }

      if (substring !== undefined) {
        localVarQueryParameter["substring"] = substring
      }

      if (vproperty !== undefined) {
        localVarQueryParameter["vproperty"] = vproperty
      }

      if (vvalue !== undefined) {
        localVarQueryParameter["vvalue"] = vvalue
      }

      if (segmentLocked !== undefined) {
        localVarQueryParameter["segmentLocked"] = segmentLocked
      }

      if (segmentRoot !== undefined) {
        localVarQueryParameter["segmentRoot"] = segmentRoot
      }

      if (minPrice !== undefined) {
        localVarQueryParameter["minPrice"] = minPrice
      }

      if (maxPrice !== undefined) {
        localVarQueryParameter["maxPrice"] = maxPrice
      }

      if (minPriceUsd !== undefined) {
        localVarQueryParameter["minPriceUsd"] = minPriceUsd
      }

      if (maxPriceUsd !== undefined) {
        localVarQueryParameter["maxPriceUsd"] = maxPriceUsd
      }

      if (changedAfter !== undefined) {
        localVarQueryParameter["changedAfter"] = (changedAfter as any).toISOString()
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view
      }

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get top segment roots
     * @summary segmentLeaders nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSegmentLeaders(ifNoneMatch?: string, options: any = {}): FetchArgs {
      const localVarPath = `/nfd/segment/leaders`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Lock/Unlock an NFD segment - if locked, the segment only allows minted names created by the segment owner.  If unlocked, anyone can mint off the segment for the price (in USD) the owner sets
     * @summary Lock/Unlock an NFD segment - specifying open price if unlocking
     * @param {SegmentLockRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSegmentLock(body: SegmentLockRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdSegmentLock.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdSegmentLock.",
        )
      }
      const localVarPath = `/nfd/segment/lock/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"SegmentLockRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Send an amount of an asset [0 == ALGO] to another account FROM the NFD Vault.  Only owner of NFD can send.
     * @summary sendFromVault nfd
     * @param {SendFromVaultRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSendFromVault(body: SendFromVaultRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdSendFromVault.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdSendFromVault.",
        )
      }
      const localVarPath = `/nfd/vault/sendFrom/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"SendFromVaultRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Provide transaction to send an asset owned by sender account to an NFD vault.  Call to have opt-in to vault will be included if necessary.  Callable by NFD owner, or if Opt-in is UNLOCKED (or asset already opted-in), anyone can call
     * @summary sendToVault nfd
     * @param {SendToVaultRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSendToVault(body: SendToVaultRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdSendToVault.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdSendToVault.",
        )
      }
      const localVarPath = `/nfd/vault/sendTo/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"SendToVaultRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set which of the currently verified addresses should be the first in the list (swapping positions as necessary)
     * @summary setPrimaryAddress nfd
     * @param {SetPrimaryAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSetPrimaryAddress(
      body: SetPrimaryAddressRequestBody,
      name: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdSetPrimaryAddress.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdSetPrimaryAddress.",
        )
      }
      const localVarPath = `/nfd/links/setPrimaryAddress/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"SetPrimaryAddressRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set the specified NFD as the primary NFD to return for the specified address via its reverse lookup
     * @summary setPrimaryNFD nfd
     * @param {SetPrimaryAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSetPrimaryNFD(
      body: SetPrimaryAddressRequestBody,
      name: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdSetPrimaryNFD.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdSetPrimaryNFD.",
        )
      }
      const localVarPath = `/nfd/links/setPrimaryNFD/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"SetPrimaryAddressRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Suggest NFDs to purchase
     * @summary suggest nfd
     * @param {string} buyer Expected buyer of name.  Used for segment minting as additional check on availability of mint
     * @param {string} name A name (even partial) to search for [receiving suggestions as well]
     * @param {number} [limit] Limit the number of results returned - max 40
     * @param {string} [view] View of data to return, brief (default), or full
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSuggest(
      buyer: string,
      name: string,
      limit?: number,
      view?: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'buyer' is not null or undefined
      if (buyer === null || buyer === undefined) {
        throw new RequiredError(
          "buyer",
          "Required parameter buyer was null or undefined when calling nfdSuggest.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdSuggest.",
        )
      }
      const localVarPath = `/nfd/suggest/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view
      }

      if (buyer !== undefined) {
        localVarQueryParameter["buyer"] = buyer
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Fetch NFD summary data - results subject to change in the future
     * @summary totals nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdTotals(ifNoneMatch?: string, options: any = {}): FetchArgs {
      const localVarPath = `/nfd/totals`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get top twitter influencers
     * @summary twitterLeaders nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdTwitterLeaders(ifNoneMatch?: string, options: any = {}): FetchArgs {
      const localVarPath = `/nfd/twitter/leaders`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "GET" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (ifNoneMatch !== undefined && ifNoneMatch !== null) {
        localVarHeaderParameter["if-none-match"] = String(ifNoneMatch)
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * UnLink one or more addresses to an NFD, adding to the reverse-address lookups as well as to this NFD.  Sender must be owner, and each added address must be able to be signed for.
     * @summary unlinkAddress nfd
     * @param {LinkAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUnlinkAddress(body: LinkAddressRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdUnlinkAddress.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdUnlinkAddress.",
        )
      }
      const localVarPath = `/nfd/links/removeAddress/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"LinkAddressRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Replace all NFD user-settable attributes with those passed-in, removing, adding and replacing on behalf of a particular sender (who must be the owner).  Returns transaction group of transactions to sign
     * @summary updateAll nfd
     * @param {UpdatePartialRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUpdateAll(body: UpdatePartialRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdUpdateAll.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdUpdateAll.",
        )
      }
      const localVarPath = `/nfd/update/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"UpdatePartialRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update the avatar or banner image associated with an NFD by uploading new image content
     * @summary updateImage nfd
     * @param {string} name
     * @param {string} sender Address that will be signing the returned transactions.  Should be owner of NFD
     * @param {string} which Which image to update, avatar or banner
     * @param {boolean} [wantTxn] Whether to return transactions to sign to update the specified image attribute within the NFD
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUpdateImage(
      name: string,
      sender: string,
      which: string,
      wantTxn?: boolean,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdUpdateImage.",
        )
      }
      // verify required parameter 'sender' is not null or undefined
      if (sender === null || sender === undefined) {
        throw new RequiredError(
          "sender",
          "Required parameter sender was null or undefined when calling nfdUpdateImage.",
        )
      }
      // verify required parameter 'which' is not null or undefined
      if (which === null || which === undefined) {
        throw new RequiredError(
          "which",
          "Required parameter which was null or undefined when calling nfdUpdateImage.",
        )
      }
      const localVarPath = `/nfd/updateImage/{name}/{sender}/{which}`
        .replace(`{${"name"}}`, encodeURIComponent(String(name)))
        .replace(`{${"sender"}}`, encodeURIComponent(String(sender)))
        .replace(`{${"which"}}`, encodeURIComponent(String(which)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (wantTxn !== undefined) {
        localVarQueryParameter["wantTxn"] = wantTxn
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Set an attribute in an NFD on behalf of a particular sender (who must be the owner).  Can set user-defined fields, or clear verified fields (except v.ca*)
     * @summary updatePartial nfd
     * @param {UpdatePartialRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUpdatePartial(body: UpdatePartialRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdUpdatePartial.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdUpdatePartial.",
        )
      }
      const localVarPath = `/nfd/update/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "PATCH" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"UpdatePartialRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Lock/Unlock ability for the specified NFD Vault to auto opt-in to assets, allowing airdrops from other accounts
     * @summary vaultOptInLock nfd
     * @param {ContractLockRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdVaultOptInLock(body: ContractLockRequestBody, name: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdVaultOptInLock.",
        )
      }
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling nfdVaultOptInLock.",
        )
      }
      const localVarPath = `/nfd/vault/lock/{name}`.replace(
        `{${"name"}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"ContractLockRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Verify a particular piece of data on, or off-chain.  Each verification differs in its requirements
     * @summary verifyConfirm nfd
     * @param {VerifyConfirmRequestBody} body
     * @param {string} id ID of challenge, must be used in subsequent confirmation call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdVerifyConfirm(body: VerifyConfirmRequestBody, id: string, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdVerifyConfirm.",
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling nfdVerifyConfirm.",
        )
      }
      const localVarPath = `/nfd/verify/confirm/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"VerifyConfirmRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Request Verification for particular piece of data on, or off-chain.  Each verification differs in its requirements. Returns data to be used in challenge
     * @summary verifyRequest nfd
     * @param {VerifyRequestRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdVerifyRequest(body: VerifyRequestRequestBody, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling nfdVerifyRequest.",
        )
      }
      const localVarPath = `/nfd/verify/request`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: "POST" }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      localVarUrlObj.search = null
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>"VerifyRequestRequestBody" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json"
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ""

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * NfdApi - functional programming interface
 * @export
 */
export const NfdApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Fetch change activity for an NFD, specifically general 'block-level' deltas for an NFD
     * @summary Fetch change activity for an NFD
     * @param {Array<string>} name Name(s) of NFDs to fetch activity for.  Specify the same query parameter multiple times for each nane, ie: name&#x3D;xxx&amp;name&#x3D;yyy&amp;name&#x3D;zzz\&quot;)
     * @param {string} [type] type of activity to retrieve
     * @param {Date} [afterTime] Fetch events that occurred only after the specified time
     * @param {number} [limit] Limit the number of results returned, per NFD - max 50
     * @param {string} [sort] What to sort on - descending timestamp is default
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdActivity(
      name: Array<string>,
      type?: string,
      afterTime?: Date,
      limit?: number,
      sort?: string,
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NFDActivity>> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdActivity(
        name,
        type,
        afterTime,
        limit,
        sort,
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Fetch NFD analytics via various filters
     * @summary Fetch NFD analytics via various filters
     * @param {string} [name] name or partial match of NFD name to filter on
     * @param {string} [buyer] Buyer address to filter on
     * @param {string} [seller] Seller address to filter on
     * @param {Array<string>} [event] one or more events to filter on
     * @param {boolean} [requireBuyer] Whether the buyer property must be present in the data.  Setting this will exclude auction mint events for eg
     * @param {boolean} [includeOwner] Whether to add a currentOwner property to each event with the &#x27;current&#x27; owner of the NFD referenced by that event
     * @param {boolean} [excludeNFDAsSeller] Whether to exclude events where NFDomains is the seller.  If set to true, and filtering on &#x27;sold&#x27; event for eg, returned items will will be secondary sales only.
     * @param {Array<string>} [category]
     * @param {Array<string>} [saleType]
     * @param {Array<string>} [length] Length of NFD
     * @param {Array<string>} [traits] Traits of NFD
     * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
     * @param {number} [minPrice] Minimum price of NFD
     * @param {number} [maxPrice] Maximum price of NFD
     * @param {Date} [afterTime] Fetch analytics events that occurred only after the specified time
     * @param {number} [limit] Limit the number of results returned - max 200
     * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     * @param {string} [sort] What to sort on - descending timestamp is default
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdAnalytics(
      name?: string,
      buyer?: string,
      seller?: string,
      event?: Array<string>,
      requireBuyer?: boolean,
      includeOwner?: boolean,
      excludeNFDAsSeller?: boolean,
      category?: Array<string>,
      saleType?: Array<string>,
      length?: Array<string>,
      traits?: Array<string>,
      parentAppID?: number,
      minPrice?: number,
      maxPrice?: number,
      afterTime?: Date,
      limit?: number,
      offset?: number,
      sort?: string,
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<NFDAnalyticRecords> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdAnalytics(
        name,
        buyer,
        seller,
        event,
        requireBuyer,
        includeOwner,
        excludeNFDAsSeller,
        category,
        saleType,
        length,
        traits,
        parentAppID,
        minPrice,
        maxPrice,
        afterTime,
        limit,
        offset,
        sort,
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Fetch badge information (ie: donations) for an NFD
     * @summary Fetch badge information (donations/etc) for an NFD
     * @param {string} name
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdBadges(
      name: string,
      ifNoneMatch?: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<{ [key: string]: Array<{ [key: string]: string }> }> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdBadges(
        name,
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     *
     * @summary Browse NFDs via various filters
     * @param {string} [name] name or partial match of NFD name to filter on
     * @param {Array<string>} [category]
     * @param {Array<string>} [saleType]
     * @param {Array<string>} [state]
     * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
     * @param {Array<string>} [length] Length of NFD
     * @param {Array<string>} [traits] Traits of NFD
     * @param {string} [owner] An Algorand account address to find all NFDs owned by that address
     * @param {string} [reservedFor] An Algorand account address to find all NFDs reserved for that address
     * @param {string} [prefix] The start of an NFD name, fetching multiple NFDs that have that prefix
     * @param {string} [substring] Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
     * @param {string} [vproperty] Verified property name to search on - specify value with vvalue
     * @param {string} [vvalue] Value to find in the vproperty field specified with the vproperty parameter
     * @param {number} [minPrice] Minimum price of NFD
     * @param {number} [maxPrice] Maximum price of NFD
     * @param {Date} [changedAfter] Fetch NFDs that changed after the specified timestamp
     * @param {number} [limit] Limit the number of results returned - max 200
     * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     * @param {string} [sort] What to sort on
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdBrowse(
      name?: string,
      category?: Array<string>,
      saleType?: Array<string>,
      state?: Array<string>,
      parentAppID?: number,
      length?: Array<string>,
      traits?: Array<string>,
      owner?: string,
      reservedFor?: string,
      prefix?: string,
      substring?: string,
      vproperty?: string,
      vvalue?: string,
      minPrice?: number,
      maxPrice?: number,
      changedAfter?: Date,
      limit?: number,
      offset?: number,
      sort?: string,
      view?: string,
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<NfdRecordCollection> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdBrowse(
        name,
        category,
        saleType,
        state,
        parentAppID,
        length,
        traits,
        owner,
        reservedFor,
        prefix,
        substring,
        vproperty,
        vvalue,
        minPrice,
        maxPrice,
        changedAfter,
        limit,
        offset,
        sort,
        view,
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Get top consensus leaders
     * @summary consensusLeaders nfd
     * @param {boolean} [requireNFD] should it only match against accounts matching NFD linked addresses
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdConsensusLeaders(
      requireNFD?: boolean,
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ConsensusRecord>> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdConsensusLeaders(
        requireNFD,
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Get general metrics about Algorand consensus
     * @summary consensusMetrics nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdConsensusMetrics(
      ifNoneMatch?: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<{ [key: string]: Array<{ [key: string]: string }> }> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdConsensusMetrics(
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Lock/Unlock an NFD contract - if locked, the contract can never being modified until unlocked again by the owner.
     * @summary contractLock nfd
     * @param {ContractLockRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdContractLock(
      body: ContractLockRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdContractLock(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Request upgrade of a pre 2.11 NFD to 2.11 (going no further)
     * @summary contractUpgrade nfd
     * @param {RescindOfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdContractUpgrade(
      body: RescindOfferRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdContractUpgrade(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Request upgrade of a 2.11 or 3.x NFD to 3.x+ (post renewals). First switch to 3.x will pay 1 year renewal fee
     * @summary ContractUpgradeV3 nfd
     * @param {RescindOfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdContractUpgradeV3(
      body: RescindOfferRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdContractUpgradeV3(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Get top donors to a specific NFD Donation target
     * @summary donationLeadersV2 nfd
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdDonationLeadersV2(
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Donation>> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdDonationLeadersV2(
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Fetch list of tracked Donation NFD 'targets'.
     * @summary donationListV2 nfd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdDonationListV2(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<NfdRecordResponseFullCollection> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdDonationListV2(options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Fetch donation activity for an NFD, totalling amounts sent 'to' designated donation accounts
     * @summary donations nfd
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdDonations(
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Donation>> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdDonations(name, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Get the primary NFD for an address.  Must be verified address, or if allowUnverified is set, it may match against an unverified address
     * @summary Reverse Address lookup with results returned per address
     * @param {Array<string>} address one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address&#x3D;xxx&amp;address&#x3D;yyy&amp;address&#x3D;zzz
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
     * @param {boolean} [allowUnverified] Whether to allow unverified addresses to match (and only if its only match).  Defaults to false
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetLookup(
      address: Array<string>,
      view?: string,
      allowUnverified?: boolean,
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: NfdRecordinaddress }> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdGetLookup(
        address,
        view,
        allowUnverified,
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Get a specific NFD by name or by its application ID
     * @summary Get a specific NFD by name or by its application ID
     * @param {string} nameOrID
     * @param {string} [view] View of data to return, tiny, brief (default), or full
     * @param {boolean} [poll] Use if polling waiting for state change - causes notFound to return as 204 instead of 404.  Should only be used when waiting for an NFD to transition from not-existing to being reserved for user to claim
     * @param {boolean} [nocache] Set to true to return a never-cached result.  Use sparingly and only during certain &#x27;NFD already exists&#x27; UX state transitions.
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetNFD(
      nameOrID: string,
      view?: string,
      poll?: boolean,
      nocache?: boolean,
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<NfdRecord> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdGetNFD(
        nameOrID,
        view,
        poll,
        nocache,
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Get all NFDs which have been explicitly linked to one or more verified [or unverified] Algorand address(es).  Unverified addresses will match but return as unverifiedCaAlgo array.  These should be treated specially and not have the same trust level as verified addresses as they can be falsely attributed.  The caAlgo array is what should be trusted for things like NFT creation addresses. For reverse lookups returning multiple NFDs, the first result should be used.
     * @summary Reverse Address lookup with results returned per address
     * @param {Array<string>} address one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address&#x3D;xxx&amp;address&#x3D;yyy&amp;address&#x3D;zzz
     * @param {number} [limit] Limit the total number of NFDs returned - automatically changed to at least be 1 per address
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetNFDsForAddressesV2(
      address: Array<string>,
      limit?: number,
      view?: string,
      ifNoneMatch?: string,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<{ [key: string]: NfdRecordinaddressCollection }> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdGetNFDsForAddressesV2(
        address,
        limit,
        view,
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Returns NameSig address for an NFD name (usable for V1 only)
     * @summary getNameSig nfd
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetNameSig(
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdGetNameSig(name, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * get price / carry cost to mint or rewnew an NFD (if existing)
     * @summary getQuote nfd
     * @param {string} buyer Address requesting price. Optional, but important when getting quote on existing nfd that is expired. If expired, then owner can renew for base price, but if not existing (but expired) owner, then the price is reverse-auction format over 28 days.
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetQuote(
      buyer: string,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GetQuoteResponseBody> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdGetQuote(
        buyer,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Returns RevAddress address for an NFD name (usable for V1 only)
     * @summary getRevAddressSig nfd
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetRevAddressSig(
      address: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdGetRevAddressSig(
        address,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Determines if specified NFD NFT ASA ID is authentic NFD
     * @summary isValidASA nfd
     * @param {number} asaID Asset ID of a presumed NFD ASA to verify.  The API will verify the found asset references an NFD that in turn references that asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdIsValidASA(
      asaID: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IsValidASAResponseBody> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdIsValidASA(asaID, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Determines if specified NFD Application ID is authentic
     * @summary isValidNFD nfd
     * @param {number} appID Application ID of a presumed NFD to verify.  The API will perform a forward-name lookup of the name within the NFD to verify it points to the same ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdIsValidNFD(
      appID: number,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<IsValidNFDResponseBody> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdIsValidNFD(appID, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Link one or more addresses to an NFD, adding to the reverse-address lookups as well as to this NFD.  Sender must be owner, and each added address must be able to be signed for.
     * @summary linkAddress nfd
     * @param {LinkAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdLinkAddress(
      body: LinkAddressRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdLinkAddress(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Mint a new NFD, with user buying specified NFD and paying for a prorated amount of time based on its yearly price.
     * @summary mint nfd
     * @param {MintRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdMint(
      body: MintRequestBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdMint(body, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Offer up an NFD for sale - specifying price and optionally an address it is reserved for.
     * @summary offer nfd
     * @param {OfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdOffer(
      body: OfferRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdOffer(body, name, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Post an offer to buy to the owner of an NFD, offering up a particular amount with optional note for them to consider
     * @summary postOfferToOwner nfd
     * @param {PostOfferToOwnerRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdPostOfferToOwner(
      body: PostOfferToOwnerRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdPostOfferToOwner(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Purchase an NFD for sale - specifying buyer (to sign transaction) and price
     * @summary purchase nfd
     * @param {PurchaseRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdPurchase(
      body: PurchaseRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdPurchase(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Renew or extend the expiration of an NFD.  If current owner, renews at base price. If other owner, can take ownership but goes through reverse auction process for first 28 days where price drops to base price - with price being for 1 year
     * @summary renew nfd
     * @param {RenewRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdRenew(
      body: RenewRequestBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdRenew(body, options)
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Rescind offer of sale. Claiming NFD back for self, and removing it for sale.
     * @summary rescindOffer nfd
     * @param {RescindOfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdRescindOffer(
      body: RescindOfferRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdRescindOffer(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Search NFDs via various filters
     * @summary Search NFDs via various filters
     * @param {string} [name] name or partial match of NFD name to filter on
     * @param {Array<string>} [category]
     * @param {Array<string>} [saleType]
     * @param {Array<string>} [state]
     * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
     * @param {Array<string>} [length] Length of NFD
     * @param {Array<string>} [traits] Traits of NFD
     * @param {string} [owner] An Algorand account address to find all NFDs owned by that address
     * @param {string} [reservedFor] An Algorand account address to find all NFDs reserved for that address
     * @param {boolean} [excludeUserReserved] Should NFDs reserved for an account (transfers for example or unclaimed winning auctions) be excluded
     * @param {string} [prefix] The start of an NFD name, fetching multiple NFDs that have that prefix
     * @param {string} [substring] Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
     * @param {string} [vproperty] Verified property name to search on - specify value with vvalue
     * @param {string} [vvalue] Value to find in the vproperty field specified with the vproperty parameter
     * @param {boolean} [segmentLocked] Whether to explicitly filter on segments being locked or unlocked.  Typically only valuable when filtering on unlocked
     * @param {boolean} [segmentRoot] Whether to explicitly filter on NFD roots or segments.  True to only see roots, False to only see segments.
     * @param {number} [minPrice] Minimum price of NFD
     * @param {number} [maxPrice] Maximum price of NFD
     * @param {number} [minPriceUsd] Minimum price of NFD Segment in USD (cents)
     * @param {number} [maxPriceUsd] Maximum price of NFD Segment in USD (cents)
     * @param {Date} [changedAfter] Fetch NFDs that changed after the specified timestamp
     * @param {number} [limit] Limit the number of results returned - max 200
     * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     * @param {string} [sort] What to sort on
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSearchV2(
      name?: string,
      category?: Array<string>,
      saleType?: Array<string>,
      state?: Array<string>,
      parentAppID?: number,
      length?: Array<string>,
      traits?: Array<string>,
      owner?: string,
      reservedFor?: string,
      excludeUserReserved?: boolean,
      prefix?: string,
      substring?: string,
      vproperty?: string,
      vvalue?: string,
      segmentLocked?: boolean,
      segmentRoot?: boolean,
      minPrice?: number,
      maxPrice?: number,
      minPriceUsd?: number,
      maxPriceUsd?: number,
      changedAfter?: Date,
      limit?: number,
      offset?: number,
      sort?: string,
      view?: string,
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<NfdV2SearchRecords> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdSearchV2(
        name,
        category,
        saleType,
        state,
        parentAppID,
        length,
        traits,
        owner,
        reservedFor,
        excludeUserReserved,
        prefix,
        substring,
        vproperty,
        vvalue,
        segmentLocked,
        segmentRoot,
        minPrice,
        maxPrice,
        minPriceUsd,
        maxPriceUsd,
        changedAfter,
        limit,
        offset,
        sort,
        view,
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Get top segment roots
     * @summary segmentLeaders nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSegmentLeaders(
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<NfdRecordCollection> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdSegmentLeaders(
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Lock/Unlock an NFD segment - if locked, the segment only allows minted names created by the segment owner.  If unlocked, anyone can mint off the segment for the price (in USD) the owner sets
     * @summary Lock/Unlock an NFD segment - specifying open price if unlocking
     * @param {SegmentLockRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSegmentLock(
      body: SegmentLockRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdSegmentLock(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Send an amount of an asset [0 == ALGO] to another account FROM the NFD Vault.  Only owner of NFD can send.
     * @summary sendFromVault nfd
     * @param {SendFromVaultRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSendFromVault(
      body: SendFromVaultRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdSendFromVault(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Provide transaction to send an asset owned by sender account to an NFD vault.  Call to have opt-in to vault will be included if necessary.  Callable by NFD owner, or if Opt-in is UNLOCKED (or asset already opted-in), anyone can call
     * @summary sendToVault nfd
     * @param {SendToVaultRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSendToVault(
      body: SendToVaultRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdSendToVault(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Set which of the currently verified addresses should be the first in the list (swapping positions as necessary)
     * @summary setPrimaryAddress nfd
     * @param {SetPrimaryAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSetPrimaryAddress(
      body: SetPrimaryAddressRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdSetPrimaryAddress(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Set the specified NFD as the primary NFD to return for the specified address via its reverse lookup
     * @summary setPrimaryNFD nfd
     * @param {SetPrimaryAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSetPrimaryNFD(
      body: SetPrimaryAddressRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdSetPrimaryNFD(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Suggest NFDs to purchase
     * @summary suggest nfd
     * @param {string} buyer Expected buyer of name.  Used for segment minting as additional check on availability of mint
     * @param {string} name A name (even partial) to search for [receiving suggestions as well]
     * @param {number} [limit] Limit the number of results returned - max 40
     * @param {string} [view] View of data to return, brief (default), or full
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSuggest(
      buyer: string,
      name: string,
      limit?: number,
      view?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<NfdRecordCollection> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdSuggest(
        buyer,
        name,
        limit,
        view,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Fetch NFD summary data - results subject to change in the future
     * @summary totals nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdTotals(
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TotalsOKResponseBody> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdTotals(
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Get top twitter influencers
     * @summary twitterLeaders nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdTwitterLeaders(
      ifNoneMatch?: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TwitterRecord>> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdTwitterLeaders(
        ifNoneMatch,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * UnLink one or more addresses to an NFD, adding to the reverse-address lookups as well as to this NFD.  Sender must be owner, and each added address must be able to be signed for.
     * @summary unlinkAddress nfd
     * @param {LinkAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUnlinkAddress(
      body: LinkAddressRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdUnlinkAddress(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Replace all NFD user-settable attributes with those passed-in, removing, adding and replacing on behalf of a particular sender (who must be the owner).  Returns transaction group of transactions to sign
     * @summary updateAll nfd
     * @param {UpdatePartialRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUpdateAll(
      body: UpdatePartialRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdUpdateAll(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Update the avatar or banner image associated with an NFD by uploading new image content
     * @summary updateImage nfd
     * @param {string} name
     * @param {string} sender Address that will be signing the returned transactions.  Should be owner of NFD
     * @param {string} which Which image to update, avatar or banner
     * @param {boolean} [wantTxn] Whether to return transactions to sign to update the specified image attribute within the NFD
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUpdateImage(
      name: string,
      sender: string,
      which: string,
      wantTxn?: boolean,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdUpdateImage(
        name,
        sender,
        which,
        wantTxn,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Set an attribute in an NFD on behalf of a particular sender (who must be the owner).  Can set user-defined fields, or clear verified fields (except v.ca*)
     * @summary updatePartial nfd
     * @param {UpdatePartialRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUpdatePartial(
      body: UpdatePartialRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdUpdatePartial(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Lock/Unlock ability for the specified NFD Vault to auto opt-in to assets, allowing airdrops from other accounts
     * @summary vaultOptInLock nfd
     * @param {ContractLockRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdVaultOptInLock(
      body: ContractLockRequestBody,
      name: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdVaultOptInLock(
        body,
        name,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Verify a particular piece of data on, or off-chain.  Each verification differs in its requirements
     * @summary verifyConfirm nfd
     * @param {VerifyConfirmRequestBody} body
     * @param {string} id ID of challenge, must be used in subsequent confirmation call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdVerifyConfirm(
      body: VerifyConfirmRequestBody,
      id: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<VerifyConfirmResponseBody> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdVerifyConfirm(
        body,
        id,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
    /**
     * Request Verification for particular piece of data on, or off-chain.  Each verification differs in its requirements. Returns data to be used in challenge
     * @summary verifyRequest nfd
     * @param {VerifyRequestRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdVerifyRequest(
      body: VerifyRequestRequestBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<VerifyRequestResponseBody> {
      const localVarFetchArgs = NfdApiFetchParamCreator(configuration).nfdVerifyRequest(
        body,
        options,
      )
      return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          },
        )
      }
    },
  }
}

/**
 * NfdApi - factory interface
 * @export
 */
export const NfdApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Fetch change activity for an NFD, specifically general 'block-level' deltas for an NFD
     * @summary Fetch change activity for an NFD
     * @param {Array<string>} name Name(s) of NFDs to fetch activity for.  Specify the same query parameter multiple times for each nane, ie: name&#x3D;xxx&amp;name&#x3D;yyy&amp;name&#x3D;zzz\&quot;)
     * @param {string} [type] type of activity to retrieve
     * @param {Date} [afterTime] Fetch events that occurred only after the specified time
     * @param {number} [limit] Limit the number of results returned, per NFD - max 50
     * @param {string} [sort] What to sort on - descending timestamp is default
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdActivity(
      name: Array<string>,
      type?: string,
      afterTime?: Date,
      limit?: number,
      sort?: string,
      ifNoneMatch?: string,
      options?: any,
    ) {
      return NfdApiFp(configuration).nfdActivity(
        name,
        type,
        afterTime,
        limit,
        sort,
        ifNoneMatch,
        options,
      )(fetch, basePath)
    },
    /**
     * Fetch NFD analytics via various filters
     * @summary Fetch NFD analytics via various filters
     * @param {string} [name] name or partial match of NFD name to filter on
     * @param {string} [buyer] Buyer address to filter on
     * @param {string} [seller] Seller address to filter on
     * @param {Array<string>} [event] one or more events to filter on
     * @param {boolean} [requireBuyer] Whether the buyer property must be present in the data.  Setting this will exclude auction mint events for eg
     * @param {boolean} [includeOwner] Whether to add a currentOwner property to each event with the &#x27;current&#x27; owner of the NFD referenced by that event
     * @param {boolean} [excludeNFDAsSeller] Whether to exclude events where NFDomains is the seller.  If set to true, and filtering on &#x27;sold&#x27; event for eg, returned items will will be secondary sales only.
     * @param {Array<string>} [category]
     * @param {Array<string>} [saleType]
     * @param {Array<string>} [length] Length of NFD
     * @param {Array<string>} [traits] Traits of NFD
     * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
     * @param {number} [minPrice] Minimum price of NFD
     * @param {number} [maxPrice] Maximum price of NFD
     * @param {Date} [afterTime] Fetch analytics events that occurred only after the specified time
     * @param {number} [limit] Limit the number of results returned - max 200
     * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     * @param {string} [sort] What to sort on - descending timestamp is default
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdAnalytics(
      name?: string,
      buyer?: string,
      seller?: string,
      event?: Array<string>,
      requireBuyer?: boolean,
      includeOwner?: boolean,
      excludeNFDAsSeller?: boolean,
      category?: Array<string>,
      saleType?: Array<string>,
      length?: Array<string>,
      traits?: Array<string>,
      parentAppID?: number,
      minPrice?: number,
      maxPrice?: number,
      afterTime?: Date,
      limit?: number,
      offset?: number,
      sort?: string,
      ifNoneMatch?: string,
      options?: any,
    ) {
      return NfdApiFp(configuration).nfdAnalytics(
        name,
        buyer,
        seller,
        event,
        requireBuyer,
        includeOwner,
        excludeNFDAsSeller,
        category,
        saleType,
        length,
        traits,
        parentAppID,
        minPrice,
        maxPrice,
        afterTime,
        limit,
        offset,
        sort,
        ifNoneMatch,
        options,
      )(fetch, basePath)
    },
    /**
     * Fetch badge information (ie: donations) for an NFD
     * @summary Fetch badge information (donations/etc) for an NFD
     * @param {string} name
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdBadges(name: string, ifNoneMatch?: string, options?: any) {
      return NfdApiFp(configuration).nfdBadges(name, ifNoneMatch, options)(fetch, basePath)
    },
    /**
     *
     * @summary Browse NFDs via various filters
     * @param {string} [name] name or partial match of NFD name to filter on
     * @param {Array<string>} [category]
     * @param {Array<string>} [saleType]
     * @param {Array<string>} [state]
     * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
     * @param {Array<string>} [length] Length of NFD
     * @param {Array<string>} [traits] Traits of NFD
     * @param {string} [owner] An Algorand account address to find all NFDs owned by that address
     * @param {string} [reservedFor] An Algorand account address to find all NFDs reserved for that address
     * @param {string} [prefix] The start of an NFD name, fetching multiple NFDs that have that prefix
     * @param {string} [substring] Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
     * @param {string} [vproperty] Verified property name to search on - specify value with vvalue
     * @param {string} [vvalue] Value to find in the vproperty field specified with the vproperty parameter
     * @param {number} [minPrice] Minimum price of NFD
     * @param {number} [maxPrice] Maximum price of NFD
     * @param {Date} [changedAfter] Fetch NFDs that changed after the specified timestamp
     * @param {number} [limit] Limit the number of results returned - max 200
     * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     * @param {string} [sort] What to sort on
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdBrowse(
      name?: string,
      category?: Array<string>,
      saleType?: Array<string>,
      state?: Array<string>,
      parentAppID?: number,
      length?: Array<string>,
      traits?: Array<string>,
      owner?: string,
      reservedFor?: string,
      prefix?: string,
      substring?: string,
      vproperty?: string,
      vvalue?: string,
      minPrice?: number,
      maxPrice?: number,
      changedAfter?: Date,
      limit?: number,
      offset?: number,
      sort?: string,
      view?: string,
      ifNoneMatch?: string,
      options?: any,
    ) {
      return NfdApiFp(configuration).nfdBrowse(
        name,
        category,
        saleType,
        state,
        parentAppID,
        length,
        traits,
        owner,
        reservedFor,
        prefix,
        substring,
        vproperty,
        vvalue,
        minPrice,
        maxPrice,
        changedAfter,
        limit,
        offset,
        sort,
        view,
        ifNoneMatch,
        options,
      )(fetch, basePath)
    },
    /**
     * Get top consensus leaders
     * @summary consensusLeaders nfd
     * @param {boolean} [requireNFD] should it only match against accounts matching NFD linked addresses
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdConsensusLeaders(requireNFD?: boolean, ifNoneMatch?: string, options?: any) {
      return NfdApiFp(configuration).nfdConsensusLeaders(
        requireNFD,
        ifNoneMatch,
        options,
      )(fetch, basePath)
    },
    /**
     * Get general metrics about Algorand consensus
     * @summary consensusMetrics nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdConsensusMetrics(ifNoneMatch?: string, options?: any) {
      return NfdApiFp(configuration).nfdConsensusMetrics(ifNoneMatch, options)(fetch, basePath)
    },
    /**
     * Lock/Unlock an NFD contract - if locked, the contract can never being modified until unlocked again by the owner.
     * @summary contractLock nfd
     * @param {ContractLockRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdContractLock(body: ContractLockRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdContractLock(body, name, options)(fetch, basePath)
    },
    /**
     * Request upgrade of a pre 2.11 NFD to 2.11 (going no further)
     * @summary contractUpgrade nfd
     * @param {RescindOfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdContractUpgrade(body: RescindOfferRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdContractUpgrade(body, name, options)(fetch, basePath)
    },
    /**
     * Request upgrade of a 2.11 or 3.x NFD to 3.x+ (post renewals). First switch to 3.x will pay 1 year renewal fee
     * @summary ContractUpgradeV3 nfd
     * @param {RescindOfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdContractUpgradeV3(body: RescindOfferRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdContractUpgradeV3(body, name, options)(fetch, basePath)
    },
    /**
     * Get top donors to a specific NFD Donation target
     * @summary donationLeadersV2 nfd
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdDonationLeadersV2(name: string, options?: any) {
      return NfdApiFp(configuration).nfdDonationLeadersV2(name, options)(fetch, basePath)
    },
    /**
     * Fetch list of tracked Donation NFD 'targets'.
     * @summary donationListV2 nfd
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdDonationListV2(options?: any) {
      return NfdApiFp(configuration).nfdDonationListV2(options)(fetch, basePath)
    },
    /**
     * Fetch donation activity for an NFD, totalling amounts sent 'to' designated donation accounts
     * @summary donations nfd
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdDonations(name: string, options?: any) {
      return NfdApiFp(configuration).nfdDonations(name, options)(fetch, basePath)
    },
    /**
     * Get the primary NFD for an address.  Must be verified address, or if allowUnverified is set, it may match against an unverified address
     * @summary Reverse Address lookup with results returned per address
     * @param {Array<string>} address one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address&#x3D;xxx&amp;address&#x3D;yyy&amp;address&#x3D;zzz
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
     * @param {boolean} [allowUnverified] Whether to allow unverified addresses to match (and only if its only match).  Defaults to false
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetLookup(
      address: Array<string>,
      view?: string,
      allowUnverified?: boolean,
      ifNoneMatch?: string,
      options?: any,
    ) {
      return NfdApiFp(configuration).nfdGetLookup(
        address,
        view,
        allowUnverified,
        ifNoneMatch,
        options,
      )(fetch, basePath)
    },
    /**
     * Get a specific NFD by name or by its application ID
     * @summary Get a specific NFD by name or by its application ID
     * @param {string} nameOrID
     * @param {string} [view] View of data to return, tiny, brief (default), or full
     * @param {boolean} [poll] Use if polling waiting for state change - causes notFound to return as 204 instead of 404.  Should only be used when waiting for an NFD to transition from not-existing to being reserved for user to claim
     * @param {boolean} [nocache] Set to true to return a never-cached result.  Use sparingly and only during certain &#x27;NFD already exists&#x27; UX state transitions.
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetNFD(
      nameOrID: string,
      view?: string,
      poll?: boolean,
      nocache?: boolean,
      ifNoneMatch?: string,
      options?: any,
    ) {
      return NfdApiFp(configuration).nfdGetNFD(
        nameOrID,
        view,
        poll,
        nocache,
        ifNoneMatch,
        options,
      )(fetch, basePath)
    },
    /**
     * Get all NFDs which have been explicitly linked to one or more verified [or unverified] Algorand address(es).  Unverified addresses will match but return as unverifiedCaAlgo array.  These should be treated specially and not have the same trust level as verified addresses as they can be falsely attributed.  The caAlgo array is what should be trusted for things like NFT creation addresses. For reverse lookups returning multiple NFDs, the first result should be used.
     * @summary Reverse Address lookup with results returned per address
     * @param {Array<string>} address one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address&#x3D;xxx&amp;address&#x3D;yyy&amp;address&#x3D;zzz
     * @param {number} [limit] Limit the total number of NFDs returned - automatically changed to at least be 1 per address
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetNFDsForAddressesV2(
      address: Array<string>,
      limit?: number,
      view?: string,
      ifNoneMatch?: string,
      options?: any,
    ) {
      return NfdApiFp(configuration).nfdGetNFDsForAddressesV2(
        address,
        limit,
        view,
        ifNoneMatch,
        options,
      )(fetch, basePath)
    },
    /**
     * Returns NameSig address for an NFD name (usable for V1 only)
     * @summary getNameSig nfd
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetNameSig(name: string, options?: any) {
      return NfdApiFp(configuration).nfdGetNameSig(name, options)(fetch, basePath)
    },
    /**
     * get price / carry cost to mint or rewnew an NFD (if existing)
     * @summary getQuote nfd
     * @param {string} buyer Address requesting price. Optional, but important when getting quote on existing nfd that is expired. If expired, then owner can renew for base price, but if not existing (but expired) owner, then the price is reverse-auction format over 28 days.
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetQuote(buyer: string, name: string, options?: any) {
      return NfdApiFp(configuration).nfdGetQuote(buyer, name, options)(fetch, basePath)
    },
    /**
     * Returns RevAddress address for an NFD name (usable for V1 only)
     * @summary getRevAddressSig nfd
     * @param {string} address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdGetRevAddressSig(address: string, options?: any) {
      return NfdApiFp(configuration).nfdGetRevAddressSig(address, options)(fetch, basePath)
    },
    /**
     * Determines if specified NFD NFT ASA ID is authentic NFD
     * @summary isValidASA nfd
     * @param {number} asaID Asset ID of a presumed NFD ASA to verify.  The API will verify the found asset references an NFD that in turn references that asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdIsValidASA(asaID: number, options?: any) {
      return NfdApiFp(configuration).nfdIsValidASA(asaID, options)(fetch, basePath)
    },
    /**
     * Determines if specified NFD Application ID is authentic
     * @summary isValidNFD nfd
     * @param {number} appID Application ID of a presumed NFD to verify.  The API will perform a forward-name lookup of the name within the NFD to verify it points to the same ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdIsValidNFD(appID: number, options?: any) {
      return NfdApiFp(configuration).nfdIsValidNFD(appID, options)(fetch, basePath)
    },
    /**
     * Link one or more addresses to an NFD, adding to the reverse-address lookups as well as to this NFD.  Sender must be owner, and each added address must be able to be signed for.
     * @summary linkAddress nfd
     * @param {LinkAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdLinkAddress(body: LinkAddressRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdLinkAddress(body, name, options)(fetch, basePath)
    },
    /**
     * Mint a new NFD, with user buying specified NFD and paying for a prorated amount of time based on its yearly price.
     * @summary mint nfd
     * @param {MintRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdMint(body: MintRequestBody, options?: any) {
      return NfdApiFp(configuration).nfdMint(body, options)(fetch, basePath)
    },
    /**
     * Offer up an NFD for sale - specifying price and optionally an address it is reserved for.
     * @summary offer nfd
     * @param {OfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdOffer(body: OfferRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdOffer(body, name, options)(fetch, basePath)
    },
    /**
     * Post an offer to buy to the owner of an NFD, offering up a particular amount with optional note for them to consider
     * @summary postOfferToOwner nfd
     * @param {PostOfferToOwnerRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdPostOfferToOwner(body: PostOfferToOwnerRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdPostOfferToOwner(body, name, options)(fetch, basePath)
    },
    /**
     * Purchase an NFD for sale - specifying buyer (to sign transaction) and price
     * @summary purchase nfd
     * @param {PurchaseRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdPurchase(body: PurchaseRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdPurchase(body, name, options)(fetch, basePath)
    },
    /**
     * Renew or extend the expiration of an NFD.  If current owner, renews at base price. If other owner, can take ownership but goes through reverse auction process for first 28 days where price drops to base price - with price being for 1 year
     * @summary renew nfd
     * @param {RenewRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdRenew(body: RenewRequestBody, options?: any) {
      return NfdApiFp(configuration).nfdRenew(body, options)(fetch, basePath)
    },
    /**
     * Rescind offer of sale. Claiming NFD back for self, and removing it for sale.
     * @summary rescindOffer nfd
     * @param {RescindOfferRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdRescindOffer(body: RescindOfferRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdRescindOffer(body, name, options)(fetch, basePath)
    },
    /**
     * Search NFDs via various filters
     * @summary Search NFDs via various filters
     * @param {string} [name] name or partial match of NFD name to filter on
     * @param {Array<string>} [category]
     * @param {Array<string>} [saleType]
     * @param {Array<string>} [state]
     * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
     * @param {Array<string>} [length] Length of NFD
     * @param {Array<string>} [traits] Traits of NFD
     * @param {string} [owner] An Algorand account address to find all NFDs owned by that address
     * @param {string} [reservedFor] An Algorand account address to find all NFDs reserved for that address
     * @param {boolean} [excludeUserReserved] Should NFDs reserved for an account (transfers for example or unclaimed winning auctions) be excluded
     * @param {string} [prefix] The start of an NFD name, fetching multiple NFDs that have that prefix
     * @param {string} [substring] Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
     * @param {string} [vproperty] Verified property name to search on - specify value with vvalue
     * @param {string} [vvalue] Value to find in the vproperty field specified with the vproperty parameter
     * @param {boolean} [segmentLocked] Whether to explicitly filter on segments being locked or unlocked.  Typically only valuable when filtering on unlocked
     * @param {boolean} [segmentRoot] Whether to explicitly filter on NFD roots or segments.  True to only see roots, False to only see segments.
     * @param {number} [minPrice] Minimum price of NFD
     * @param {number} [maxPrice] Maximum price of NFD
     * @param {number} [minPriceUsd] Minimum price of NFD Segment in USD (cents)
     * @param {number} [maxPriceUsd] Maximum price of NFD Segment in USD (cents)
     * @param {Date} [changedAfter] Fetch NFDs that changed after the specified timestamp
     * @param {number} [limit] Limit the number of results returned - max 200
     * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
     * @param {string} [sort] What to sort on
     * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSearchV2(
      name?: string,
      category?: Array<string>,
      saleType?: Array<string>,
      state?: Array<string>,
      parentAppID?: number,
      length?: Array<string>,
      traits?: Array<string>,
      owner?: string,
      reservedFor?: string,
      excludeUserReserved?: boolean,
      prefix?: string,
      substring?: string,
      vproperty?: string,
      vvalue?: string,
      segmentLocked?: boolean,
      segmentRoot?: boolean,
      minPrice?: number,
      maxPrice?: number,
      minPriceUsd?: number,
      maxPriceUsd?: number,
      changedAfter?: Date,
      limit?: number,
      offset?: number,
      sort?: string,
      view?: string,
      ifNoneMatch?: string,
      options?: any,
    ) {
      return NfdApiFp(configuration).nfdSearchV2(
        name,
        category,
        saleType,
        state,
        parentAppID,
        length,
        traits,
        owner,
        reservedFor,
        excludeUserReserved,
        prefix,
        substring,
        vproperty,
        vvalue,
        segmentLocked,
        segmentRoot,
        minPrice,
        maxPrice,
        minPriceUsd,
        maxPriceUsd,
        changedAfter,
        limit,
        offset,
        sort,
        view,
        ifNoneMatch,
        options,
      )(fetch, basePath)
    },
    /**
     * Get top segment roots
     * @summary segmentLeaders nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSegmentLeaders(ifNoneMatch?: string, options?: any) {
      return NfdApiFp(configuration).nfdSegmentLeaders(ifNoneMatch, options)(fetch, basePath)
    },
    /**
     * Lock/Unlock an NFD segment - if locked, the segment only allows minted names created by the segment owner.  If unlocked, anyone can mint off the segment for the price (in USD) the owner sets
     * @summary Lock/Unlock an NFD segment - specifying open price if unlocking
     * @param {SegmentLockRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSegmentLock(body: SegmentLockRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdSegmentLock(body, name, options)(fetch, basePath)
    },
    /**
     * Send an amount of an asset [0 == ALGO] to another account FROM the NFD Vault.  Only owner of NFD can send.
     * @summary sendFromVault nfd
     * @param {SendFromVaultRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSendFromVault(body: SendFromVaultRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdSendFromVault(body, name, options)(fetch, basePath)
    },
    /**
     * Provide transaction to send an asset owned by sender account to an NFD vault.  Call to have opt-in to vault will be included if necessary.  Callable by NFD owner, or if Opt-in is UNLOCKED (or asset already opted-in), anyone can call
     * @summary sendToVault nfd
     * @param {SendToVaultRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSendToVault(body: SendToVaultRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdSendToVault(body, name, options)(fetch, basePath)
    },
    /**
     * Set which of the currently verified addresses should be the first in the list (swapping positions as necessary)
     * @summary setPrimaryAddress nfd
     * @param {SetPrimaryAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSetPrimaryAddress(body: SetPrimaryAddressRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdSetPrimaryAddress(body, name, options)(fetch, basePath)
    },
    /**
     * Set the specified NFD as the primary NFD to return for the specified address via its reverse lookup
     * @summary setPrimaryNFD nfd
     * @param {SetPrimaryAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSetPrimaryNFD(body: SetPrimaryAddressRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdSetPrimaryNFD(body, name, options)(fetch, basePath)
    },
    /**
     * Suggest NFDs to purchase
     * @summary suggest nfd
     * @param {string} buyer Expected buyer of name.  Used for segment minting as additional check on availability of mint
     * @param {string} name A name (even partial) to search for [receiving suggestions as well]
     * @param {number} [limit] Limit the number of results returned - max 40
     * @param {string} [view] View of data to return, brief (default), or full
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdSuggest(buyer: string, name: string, limit?: number, view?: string, options?: any) {
      return NfdApiFp(configuration).nfdSuggest(buyer, name, limit, view, options)(fetch, basePath)
    },
    /**
     * Fetch NFD summary data - results subject to change in the future
     * @summary totals nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdTotals(ifNoneMatch?: string, options?: any) {
      return NfdApiFp(configuration).nfdTotals(ifNoneMatch, options)(fetch, basePath)
    },
    /**
     * Get top twitter influencers
     * @summary twitterLeaders nfd
     * @param {string} [ifNoneMatch] etag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdTwitterLeaders(ifNoneMatch?: string, options?: any) {
      return NfdApiFp(configuration).nfdTwitterLeaders(ifNoneMatch, options)(fetch, basePath)
    },
    /**
     * UnLink one or more addresses to an NFD, adding to the reverse-address lookups as well as to this NFD.  Sender must be owner, and each added address must be able to be signed for.
     * @summary unlinkAddress nfd
     * @param {LinkAddressRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUnlinkAddress(body: LinkAddressRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdUnlinkAddress(body, name, options)(fetch, basePath)
    },
    /**
     * Replace all NFD user-settable attributes with those passed-in, removing, adding and replacing on behalf of a particular sender (who must be the owner).  Returns transaction group of transactions to sign
     * @summary updateAll nfd
     * @param {UpdatePartialRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUpdateAll(body: UpdatePartialRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdUpdateAll(body, name, options)(fetch, basePath)
    },
    /**
     * Update the avatar or banner image associated with an NFD by uploading new image content
     * @summary updateImage nfd
     * @param {string} name
     * @param {string} sender Address that will be signing the returned transactions.  Should be owner of NFD
     * @param {string} which Which image to update, avatar or banner
     * @param {boolean} [wantTxn] Whether to return transactions to sign to update the specified image attribute within the NFD
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUpdateImage(name: string, sender: string, which: string, wantTxn?: boolean, options?: any) {
      return NfdApiFp(configuration).nfdUpdateImage(
        name,
        sender,
        which,
        wantTxn,
        options,
      )(fetch, basePath)
    },
    /**
     * Set an attribute in an NFD on behalf of a particular sender (who must be the owner).  Can set user-defined fields, or clear verified fields (except v.ca*)
     * @summary updatePartial nfd
     * @param {UpdatePartialRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdUpdatePartial(body: UpdatePartialRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdUpdatePartial(body, name, options)(fetch, basePath)
    },
    /**
     * Lock/Unlock ability for the specified NFD Vault to auto opt-in to assets, allowing airdrops from other accounts
     * @summary vaultOptInLock nfd
     * @param {ContractLockRequestBody} body
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdVaultOptInLock(body: ContractLockRequestBody, name: string, options?: any) {
      return NfdApiFp(configuration).nfdVaultOptInLock(body, name, options)(fetch, basePath)
    },
    /**
     * Verify a particular piece of data on, or off-chain.  Each verification differs in its requirements
     * @summary verifyConfirm nfd
     * @param {VerifyConfirmRequestBody} body
     * @param {string} id ID of challenge, must be used in subsequent confirmation call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdVerifyConfirm(body: VerifyConfirmRequestBody, id: string, options?: any) {
      return NfdApiFp(configuration).nfdVerifyConfirm(body, id, options)(fetch, basePath)
    },
    /**
     * Request Verification for particular piece of data on, or off-chain.  Each verification differs in its requirements. Returns data to be used in challenge
     * @summary verifyRequest nfd
     * @param {VerifyRequestRequestBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nfdVerifyRequest(body: VerifyRequestRequestBody, options?: any) {
      return NfdApiFp(configuration).nfdVerifyRequest(body, options)(fetch, basePath)
    },
  }
}

/**
 * NfdApi - object-oriented interface
 * @export
 * @class NfdApi
 * @extends {BaseAPI}
 */
export class NfdApi extends BaseAPI {
  /**
   * Fetch change activity for an NFD, specifically general 'block-level' deltas for an NFD
   * @summary Fetch change activity for an NFD
   * @param {Array<string>} name Name(s) of NFDs to fetch activity for.  Specify the same query parameter multiple times for each nane, ie: name&#x3D;xxx&amp;name&#x3D;yyy&amp;name&#x3D;zzz\&quot;)
   * @param {string} [type] type of activity to retrieve
   * @param {Date} [afterTime] Fetch events that occurred only after the specified time
   * @param {number} [limit] Limit the number of results returned, per NFD - max 50
   * @param {string} [sort] What to sort on - descending timestamp is default
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdActivity(
    name: Array<string>,
    type?: string,
    afterTime?: Date,
    limit?: number,
    sort?: string,
    ifNoneMatch?: string,
    options?: any,
  ) {
    return NfdApiFp(this.configuration).nfdActivity(
      name,
      type,
      afterTime,
      limit,
      sort,
      ifNoneMatch,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Fetch NFD analytics via various filters
   * @summary Fetch NFD analytics via various filters
   * @param {string} [name] name or partial match of NFD name to filter on
   * @param {string} [buyer] Buyer address to filter on
   * @param {string} [seller] Seller address to filter on
   * @param {Array<string>} [event] one or more events to filter on
   * @param {boolean} [requireBuyer] Whether the buyer property must be present in the data.  Setting this will exclude auction mint events for eg
   * @param {boolean} [includeOwner] Whether to add a currentOwner property to each event with the &#x27;current&#x27; owner of the NFD referenced by that event
   * @param {boolean} [excludeNFDAsSeller] Whether to exclude events where NFDomains is the seller.  If set to true, and filtering on &#x27;sold&#x27; event for eg, returned items will will be secondary sales only.
   * @param {Array<string>} [category]
   * @param {Array<string>} [saleType]
   * @param {Array<string>} [length] Length of NFD
   * @param {Array<string>} [traits] Traits of NFD
   * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
   * @param {number} [minPrice] Minimum price of NFD
   * @param {number} [maxPrice] Maximum price of NFD
   * @param {Date} [afterTime] Fetch analytics events that occurred only after the specified time
   * @param {number} [limit] Limit the number of results returned - max 200
   * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
   * @param {string} [sort] What to sort on - descending timestamp is default
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdAnalytics(
    name?: string,
    buyer?: string,
    seller?: string,
    event?: Array<string>,
    requireBuyer?: boolean,
    includeOwner?: boolean,
    excludeNFDAsSeller?: boolean,
    category?: Array<string>,
    saleType?: Array<string>,
    length?: Array<string>,
    traits?: Array<string>,
    parentAppID?: number,
    minPrice?: number,
    maxPrice?: number,
    afterTime?: Date,
    limit?: number,
    offset?: number,
    sort?: string,
    ifNoneMatch?: string,
    options?: any,
  ) {
    return NfdApiFp(this.configuration).nfdAnalytics(
      name,
      buyer,
      seller,
      event,
      requireBuyer,
      includeOwner,
      excludeNFDAsSeller,
      category,
      saleType,
      length,
      traits,
      parentAppID,
      minPrice,
      maxPrice,
      afterTime,
      limit,
      offset,
      sort,
      ifNoneMatch,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Fetch badge information (ie: donations) for an NFD
   * @summary Fetch badge information (donations/etc) for an NFD
   * @param {string} name
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdBadges(name: string, ifNoneMatch?: string, options?: any) {
    return NfdApiFp(this.configuration).nfdBadges(
      name,
      ifNoneMatch,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Browse NFDs via various filters
   * @param {string} [name] name or partial match of NFD name to filter on
   * @param {Array<string>} [category]
   * @param {Array<string>} [saleType]
   * @param {Array<string>} [state]
   * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
   * @param {Array<string>} [length] Length of NFD
   * @param {Array<string>} [traits] Traits of NFD
   * @param {string} [owner] An Algorand account address to find all NFDs owned by that address
   * @param {string} [reservedFor] An Algorand account address to find all NFDs reserved for that address
   * @param {string} [prefix] The start of an NFD name, fetching multiple NFDs that have that prefix
   * @param {string} [substring] Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
   * @param {string} [vproperty] Verified property name to search on - specify value with vvalue
   * @param {string} [vvalue] Value to find in the vproperty field specified with the vproperty parameter
   * @param {number} [minPrice] Minimum price of NFD
   * @param {number} [maxPrice] Maximum price of NFD
   * @param {Date} [changedAfter] Fetch NFDs that changed after the specified timestamp
   * @param {number} [limit] Limit the number of results returned - max 200
   * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
   * @param {string} [sort] What to sort on
   * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdBrowse(
    name?: string,
    category?: Array<string>,
    saleType?: Array<string>,
    state?: Array<string>,
    parentAppID?: number,
    length?: Array<string>,
    traits?: Array<string>,
    owner?: string,
    reservedFor?: string,
    prefix?: string,
    substring?: string,
    vproperty?: string,
    vvalue?: string,
    minPrice?: number,
    maxPrice?: number,
    changedAfter?: Date,
    limit?: number,
    offset?: number,
    sort?: string,
    view?: string,
    ifNoneMatch?: string,
    options?: any,
  ) {
    return NfdApiFp(this.configuration).nfdBrowse(
      name,
      category,
      saleType,
      state,
      parentAppID,
      length,
      traits,
      owner,
      reservedFor,
      prefix,
      substring,
      vproperty,
      vvalue,
      minPrice,
      maxPrice,
      changedAfter,
      limit,
      offset,
      sort,
      view,
      ifNoneMatch,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Get top consensus leaders
   * @summary consensusLeaders nfd
   * @param {boolean} [requireNFD] should it only match against accounts matching NFD linked addresses
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdConsensusLeaders(requireNFD?: boolean, ifNoneMatch?: string, options?: any) {
    return NfdApiFp(this.configuration).nfdConsensusLeaders(
      requireNFD,
      ifNoneMatch,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Get general metrics about Algorand consensus
   * @summary consensusMetrics nfd
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdConsensusMetrics(ifNoneMatch?: string, options?: any) {
    return NfdApiFp(this.configuration).nfdConsensusMetrics(ifNoneMatch, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * Lock/Unlock an NFD contract - if locked, the contract can never being modified until unlocked again by the owner.
   * @summary contractLock nfd
   * @param {ContractLockRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdContractLock(body: ContractLockRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdContractLock(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Request upgrade of a pre 2.11 NFD to 2.11 (going no further)
   * @summary contractUpgrade nfd
   * @param {RescindOfferRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdContractUpgrade(body: RescindOfferRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdContractUpgrade(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Request upgrade of a 2.11 or 3.x NFD to 3.x+ (post renewals). First switch to 3.x will pay 1 year renewal fee
   * @summary ContractUpgradeV3 nfd
   * @param {RescindOfferRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdContractUpgradeV3(body: RescindOfferRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdContractUpgradeV3(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Get top donors to a specific NFD Donation target
   * @summary donationLeadersV2 nfd
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdDonationLeadersV2(name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdDonationLeadersV2(name, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * Fetch list of tracked Donation NFD 'targets'.
   * @summary donationListV2 nfd
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdDonationListV2(options?: any) {
    return NfdApiFp(this.configuration).nfdDonationListV2(options)(this.fetch, this.basePath)
  }

  /**
   * Fetch donation activity for an NFD, totalling amounts sent 'to' designated donation accounts
   * @summary donations nfd
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdDonations(name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdDonations(name, options)(this.fetch, this.basePath)
  }

  /**
   * Get the primary NFD for an address.  Must be verified address, or if allowUnverified is set, it may match against an unverified address
   * @summary Reverse Address lookup with results returned per address
   * @param {Array<string>} address one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address&#x3D;xxx&amp;address&#x3D;yyy&amp;address&#x3D;zzz
   * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
   * @param {boolean} [allowUnverified] Whether to allow unverified addresses to match (and only if its only match).  Defaults to false
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdGetLookup(
    address: Array<string>,
    view?: string,
    allowUnverified?: boolean,
    ifNoneMatch?: string,
    options?: any,
  ) {
    return NfdApiFp(this.configuration).nfdGetLookup(
      address,
      view,
      allowUnverified,
      ifNoneMatch,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Get a specific NFD by name or by its application ID
   * @summary Get a specific NFD by name or by its application ID
   * @param {string} nameOrID
   * @param {string} [view] View of data to return, tiny, brief (default), or full
   * @param {boolean} [poll] Use if polling waiting for state change - causes notFound to return as 204 instead of 404.  Should only be used when waiting for an NFD to transition from not-existing to being reserved for user to claim
   * @param {boolean} [nocache] Set to true to return a never-cached result.  Use sparingly and only during certain &#x27;NFD already exists&#x27; UX state transitions.
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdGetNFD(
    nameOrID: string,
    view?: string,
    poll?: boolean,
    nocache?: boolean,
    ifNoneMatch?: string,
    options?: any,
  ) {
    return NfdApiFp(this.configuration).nfdGetNFD(
      nameOrID,
      view,
      poll,
      nocache,
      ifNoneMatch,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Get all NFDs which have been explicitly linked to one or more verified [or unverified] Algorand address(es).  Unverified addresses will match but return as unverifiedCaAlgo array.  These should be treated specially and not have the same trust level as verified addresses as they can be falsely attributed.  The caAlgo array is what should be trusted for things like NFT creation addresses. For reverse lookups returning multiple NFDs, the first result should be used.
   * @summary Reverse Address lookup with results returned per address
   * @param {Array<string>} address one or more addresses (algo or otherwise) to look up, maximum of 20 can be defined.  Specify the same query parameter multiple times for each address, ie: address&#x3D;xxx&amp;address&#x3D;yyy&amp;address&#x3D;zzz
   * @param {number} [limit] Limit the total number of NFDs returned - automatically changed to at least be 1 per address
   * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only [default]), thumbnail (tiny + avatar), brief, or full
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdGetNFDsForAddressesV2(
    address: Array<string>,
    limit?: number,
    view?: string,
    ifNoneMatch?: string,
    options?: any,
  ) {
    return NfdApiFp(this.configuration).nfdGetNFDsForAddressesV2(
      address,
      limit,
      view,
      ifNoneMatch,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Returns NameSig address for an NFD name (usable for V1 only)
   * @summary getNameSig nfd
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdGetNameSig(name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdGetNameSig(name, options)(this.fetch, this.basePath)
  }

  /**
   * get price / carry cost to mint or rewnew an NFD (if existing)
   * @summary getQuote nfd
   * @param {string} buyer Address requesting price. Optional, but important when getting quote on existing nfd that is expired. If expired, then owner can renew for base price, but if not existing (but expired) owner, then the price is reverse-auction format over 28 days.
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdGetQuote(buyer: string, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdGetQuote(buyer, name, options)(this.fetch, this.basePath)
  }

  /**
   * Returns RevAddress address for an NFD name (usable for V1 only)
   * @summary getRevAddressSig nfd
   * @param {string} address
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdGetRevAddressSig(address: string, options?: any) {
    return NfdApiFp(this.configuration).nfdGetRevAddressSig(address, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * Determines if specified NFD NFT ASA ID is authentic NFD
   * @summary isValidASA nfd
   * @param {number} asaID Asset ID of a presumed NFD ASA to verify.  The API will verify the found asset references an NFD that in turn references that asset.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdIsValidASA(asaID: number, options?: any) {
    return NfdApiFp(this.configuration).nfdIsValidASA(asaID, options)(this.fetch, this.basePath)
  }

  /**
   * Determines if specified NFD Application ID is authentic
   * @summary isValidNFD nfd
   * @param {number} appID Application ID of a presumed NFD to verify.  The API will perform a forward-name lookup of the name within the NFD to verify it points to the same ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdIsValidNFD(appID: number, options?: any) {
    return NfdApiFp(this.configuration).nfdIsValidNFD(appID, options)(this.fetch, this.basePath)
  }

  /**
   * Link one or more addresses to an NFD, adding to the reverse-address lookups as well as to this NFD.  Sender must be owner, and each added address must be able to be signed for.
   * @summary linkAddress nfd
   * @param {LinkAddressRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdLinkAddress(body: LinkAddressRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdLinkAddress(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Mint a new NFD, with user buying specified NFD and paying for a prorated amount of time based on its yearly price.
   * @summary mint nfd
   * @param {MintRequestBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdMint(body: MintRequestBody, options?: any) {
    return NfdApiFp(this.configuration).nfdMint(body, options)(this.fetch, this.basePath)
  }

  /**
   * Offer up an NFD for sale - specifying price and optionally an address it is reserved for.
   * @summary offer nfd
   * @param {OfferRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdOffer(body: OfferRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdOffer(body, name, options)(this.fetch, this.basePath)
  }

  /**
   * Post an offer to buy to the owner of an NFD, offering up a particular amount with optional note for them to consider
   * @summary postOfferToOwner nfd
   * @param {PostOfferToOwnerRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdPostOfferToOwner(body: PostOfferToOwnerRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdPostOfferToOwner(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Purchase an NFD for sale - specifying buyer (to sign transaction) and price
   * @summary purchase nfd
   * @param {PurchaseRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdPurchase(body: PurchaseRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdPurchase(body, name, options)(this.fetch, this.basePath)
  }

  /**
   * Renew or extend the expiration of an NFD.  If current owner, renews at base price. If other owner, can take ownership but goes through reverse auction process for first 28 days where price drops to base price - with price being for 1 year
   * @summary renew nfd
   * @param {RenewRequestBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdRenew(body: RenewRequestBody, options?: any) {
    return NfdApiFp(this.configuration).nfdRenew(body, options)(this.fetch, this.basePath)
  }

  /**
   * Rescind offer of sale. Claiming NFD back for self, and removing it for sale.
   * @summary rescindOffer nfd
   * @param {RescindOfferRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdRescindOffer(body: RescindOfferRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdRescindOffer(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Search NFDs via various filters
   * @summary Search NFDs via various filters
   * @param {string} [name] name or partial match of NFD name to filter on
   * @param {Array<string>} [category]
   * @param {Array<string>} [saleType]
   * @param {Array<string>} [state]
   * @param {number} [parentAppID] The parent NFD Application ID to find. Used for fetching segments of an NFD
   * @param {Array<string>} [length] Length of NFD
   * @param {Array<string>} [traits] Traits of NFD
   * @param {string} [owner] An Algorand account address to find all NFDs owned by that address
   * @param {string} [reservedFor] An Algorand account address to find all NFDs reserved for that address
   * @param {boolean} [excludeUserReserved] Should NFDs reserved for an account (transfers for example or unclaimed winning auctions) be excluded
   * @param {string} [prefix] The start of an NFD name, fetching multiple NFDs that have that prefix
   * @param {string} [substring] Part of an NFD name, fetching multiple NFDs that have that substring (minimum 3 characters)
   * @param {string} [vproperty] Verified property name to search on - specify value with vvalue
   * @param {string} [vvalue] Value to find in the vproperty field specified with the vproperty parameter
   * @param {boolean} [segmentLocked] Whether to explicitly filter on segments being locked or unlocked.  Typically only valuable when filtering on unlocked
   * @param {boolean} [segmentRoot] Whether to explicitly filter on NFD roots or segments.  True to only see roots, False to only see segments.
   * @param {number} [minPrice] Minimum price of NFD
   * @param {number} [maxPrice] Maximum price of NFD
   * @param {number} [minPriceUsd] Minimum price of NFD Segment in USD (cents)
   * @param {number} [maxPriceUsd] Maximum price of NFD Segment in USD (cents)
   * @param {Date} [changedAfter] Fetch NFDs that changed after the specified timestamp
   * @param {number} [limit] Limit the number of results returned - max 200
   * @param {number} [offset] Starting document in large list.  Fetch 1-100 [limit 100], pass offset 100 to fetch 100-200
   * @param {string} [sort] What to sort on
   * @param {string} [view] View of data to return, tiny (name, owner, caAlgo, unverifiedCaAlgo only), brief (default), or full
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdSearchV2(
    name?: string,
    category?: Array<string>,
    saleType?: Array<string>,
    state?: Array<string>,
    parentAppID?: number,
    length?: Array<string>,
    traits?: Array<string>,
    owner?: string,
    reservedFor?: string,
    excludeUserReserved?: boolean,
    prefix?: string,
    substring?: string,
    vproperty?: string,
    vvalue?: string,
    segmentLocked?: boolean,
    segmentRoot?: boolean,
    minPrice?: number,
    maxPrice?: number,
    minPriceUsd?: number,
    maxPriceUsd?: number,
    changedAfter?: Date,
    limit?: number,
    offset?: number,
    sort?: string,
    view?: string,
    ifNoneMatch?: string,
    options?: any,
  ) {
    return NfdApiFp(this.configuration).nfdSearchV2(
      name,
      category,
      saleType,
      state,
      parentAppID,
      length,
      traits,
      owner,
      reservedFor,
      excludeUserReserved,
      prefix,
      substring,
      vproperty,
      vvalue,
      segmentLocked,
      segmentRoot,
      minPrice,
      maxPrice,
      minPriceUsd,
      maxPriceUsd,
      changedAfter,
      limit,
      offset,
      sort,
      view,
      ifNoneMatch,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Get top segment roots
   * @summary segmentLeaders nfd
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdSegmentLeaders(ifNoneMatch?: string, options?: any) {
    return NfdApiFp(this.configuration).nfdSegmentLeaders(ifNoneMatch, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * Lock/Unlock an NFD segment - if locked, the segment only allows minted names created by the segment owner.  If unlocked, anyone can mint off the segment for the price (in USD) the owner sets
   * @summary Lock/Unlock an NFD segment - specifying open price if unlocking
   * @param {SegmentLockRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdSegmentLock(body: SegmentLockRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdSegmentLock(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Send an amount of an asset [0 == ALGO] to another account FROM the NFD Vault.  Only owner of NFD can send.
   * @summary sendFromVault nfd
   * @param {SendFromVaultRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdSendFromVault(body: SendFromVaultRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdSendFromVault(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Provide transaction to send an asset owned by sender account to an NFD vault.  Call to have opt-in to vault will be included if necessary.  Callable by NFD owner, or if Opt-in is UNLOCKED (or asset already opted-in), anyone can call
   * @summary sendToVault nfd
   * @param {SendToVaultRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdSendToVault(body: SendToVaultRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdSendToVault(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Set which of the currently verified addresses should be the first in the list (swapping positions as necessary)
   * @summary setPrimaryAddress nfd
   * @param {SetPrimaryAddressRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdSetPrimaryAddress(body: SetPrimaryAddressRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdSetPrimaryAddress(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Set the specified NFD as the primary NFD to return for the specified address via its reverse lookup
   * @summary setPrimaryNFD nfd
   * @param {SetPrimaryAddressRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdSetPrimaryNFD(body: SetPrimaryAddressRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdSetPrimaryNFD(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Suggest NFDs to purchase
   * @summary suggest nfd
   * @param {string} buyer Expected buyer of name.  Used for segment minting as additional check on availability of mint
   * @param {string} name A name (even partial) to search for [receiving suggestions as well]
   * @param {number} [limit] Limit the number of results returned - max 40
   * @param {string} [view] View of data to return, brief (default), or full
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdSuggest(buyer: string, name: string, limit?: number, view?: string, options?: any) {
    return NfdApiFp(this.configuration).nfdSuggest(
      buyer,
      name,
      limit,
      view,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Fetch NFD summary data - results subject to change in the future
   * @summary totals nfd
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdTotals(ifNoneMatch?: string, options?: any) {
    return NfdApiFp(this.configuration).nfdTotals(ifNoneMatch, options)(this.fetch, this.basePath)
  }

  /**
   * Get top twitter influencers
   * @summary twitterLeaders nfd
   * @param {string} [ifNoneMatch] etag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdTwitterLeaders(ifNoneMatch?: string, options?: any) {
    return NfdApiFp(this.configuration).nfdTwitterLeaders(ifNoneMatch, options)(
      this.fetch,
      this.basePath,
    )
  }

  /**
   * UnLink one or more addresses to an NFD, adding to the reverse-address lookups as well as to this NFD.  Sender must be owner, and each added address must be able to be signed for.
   * @summary unlinkAddress nfd
   * @param {LinkAddressRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdUnlinkAddress(body: LinkAddressRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdUnlinkAddress(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Replace all NFD user-settable attributes with those passed-in, removing, adding and replacing on behalf of a particular sender (who must be the owner).  Returns transaction group of transactions to sign
   * @summary updateAll nfd
   * @param {UpdatePartialRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdUpdateAll(body: UpdatePartialRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdUpdateAll(body, name, options)(this.fetch, this.basePath)
  }

  /**
   * Update the avatar or banner image associated with an NFD by uploading new image content
   * @summary updateImage nfd
   * @param {string} name
   * @param {string} sender Address that will be signing the returned transactions.  Should be owner of NFD
   * @param {string} which Which image to update, avatar or banner
   * @param {boolean} [wantTxn] Whether to return transactions to sign to update the specified image attribute within the NFD
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdUpdateImage(
    name: string,
    sender: string,
    which: string,
    wantTxn?: boolean,
    options?: any,
  ) {
    return NfdApiFp(this.configuration).nfdUpdateImage(
      name,
      sender,
      which,
      wantTxn,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Set an attribute in an NFD on behalf of a particular sender (who must be the owner).  Can set user-defined fields, or clear verified fields (except v.ca*)
   * @summary updatePartial nfd
   * @param {UpdatePartialRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdUpdatePartial(body: UpdatePartialRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdUpdatePartial(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Lock/Unlock ability for the specified NFD Vault to auto opt-in to assets, allowing airdrops from other accounts
   * @summary vaultOptInLock nfd
   * @param {ContractLockRequestBody} body
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdVaultOptInLock(body: ContractLockRequestBody, name: string, options?: any) {
    return NfdApiFp(this.configuration).nfdVaultOptInLock(
      body,
      name,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Verify a particular piece of data on, or off-chain.  Each verification differs in its requirements
   * @summary verifyConfirm nfd
   * @param {VerifyConfirmRequestBody} body
   * @param {string} id ID of challenge, must be used in subsequent confirmation call
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdVerifyConfirm(body: VerifyConfirmRequestBody, id: string, options?: any) {
    return NfdApiFp(this.configuration).nfdVerifyConfirm(
      body,
      id,
      options,
    )(this.fetch, this.basePath)
  }

  /**
   * Request Verification for particular piece of data on, or off-chain.  Each verification differs in its requirements. Returns data to be used in challenge
   * @summary verifyRequest nfd
   * @param {VerifyRequestRequestBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NfdApi
   */
  public nfdVerifyRequest(body: VerifyRequestRequestBody, options?: any) {
    return NfdApiFp(this.configuration).nfdVerifyRequest(body, options)(this.fetch, this.basePath)
  }
}
